/* ZBOSS Zigbee software protocol stack
 *
 * Copyright (c) 2012-2020 DSR Corporation, Denver CO, USA.
 * www.dsr-zboss.com
 * www.dsr-corporation.com
 * All rights reserved.
 *
 * This is unpublished proprietary source code of DSR Corporation
 * The copyright notice does not evidence any actual or intended
 * publication of such source code.
 *
 * ZBOSS is a registered trademark of Data Storage Research LLC d/b/a DSR
 * Corporation
 *
 * Commercial Usage
 * Licensees holding valid DSR Commercial licenses may use
 * this file in accordance with the DSR Commercial License
 * Agreement provided with the Software or, alternatively, in accordance
 * with the terms contained in a written agreement between you and
 * DSR.
 */
/*  PURPOSE: Smart Energy Key Establishment Cluster (Server and Client)
*/

#define ZB_TRACE_FILE_ID 3895

#include "zb_common.h"

#ifdef ZB_ENABLE_SE_MIN_CONFIG
/**
 * Common definitions for Server and Client
 */
#if defined ZB_SE_ENABLE_KEC_CLUSTER

#include "zb_se.h"
#include "zb_aps.h"
#include "zb_ecc.h"

#ifdef ZB_TH_ENABLED
static zb_uint8_t KEC_SRV_CH_DELAY_IKE_TIME;
static zb_uint8_t KEC_SRV_CH_DELAY_EPH_TIME;
static zb_uint8_t KEC_SRV_CH_DELAY_CNF_TIME;
static zb_uint8_t KEC_CLI_CH_DELAY_EPH_TIME;
static zb_uint8_t KEC_CLI_CH_DELAY_CNF_TIME;
static zb_bool_t KEC_CH_SKIP_MAC_CHECK;

void zse_kec_set_ch_srv_delays (zb_uint8_t x, zb_uint8_t y, zb_uint8_t z)
{
  KEC_SRV_CH_DELAY_IKE_TIME = x;
  KEC_SRV_CH_DELAY_EPH_TIME = y;
  KEC_SRV_CH_DELAY_CNF_TIME = z;
}

void zse_kec_set_ch_cli_delays (zb_uint8_t x, zb_uint8_t y)
{
  KEC_CLI_CH_DELAY_EPH_TIME = x;
  KEC_CLI_CH_DELAY_CNF_TIME = y;
}

void zse_kec_ch_skip_mac_check(void)
{
  KEC_CH_SKIP_MAC_CHECK = ZB_TRUE;
}
#endif /* ZB_TH_ENABLED */

/**
 * The initiator device's implicit certificate used to transfer the initiator device's public key
 * (denoted Q1,U in the Elliptic Curve MQV scheme in SEC1 [B18]) and the initiator device's identity.
 */
const zb_uint8_t ZB_CERT_SIZE[2] = {48,74};

/**
 * The ephemeral public key generated by the responder device
 * (denoted Q2,V in the Elliptic Curve MQV scheme in SEC1 [B18])
 */
const zb_uint8_t ZB_QE_SIZE[2] = {22,37};

/**
 * The ephemeral private key generated by the responder device
 * (denoted Q2,V  in the Elliptic Curve MQV scheme in SEC1 [B18])
 */
const zb_uint8_t ZB_PR_SIZE[2] = {21,36};

/**
 * Shared key size
 */
static const zb_uint8_t ZB_SK_SIZE[2] = {21,36};

/**
 * The secure message authentication code generated by the initiator device
 * (where the message M is
 * ( 0216 || ID U || ID V || QEU || QEV ) and ID U and ID V are the initiator and responder device
 * ( 0316 || ID V || ID U || QEV || QEU) and ID V and ID U are the responder and initiator device
 * entities respectively as specified in sub-clause C.4.2.2.3 and QEU and QEV are the point-compressed
 * elliptic curve points representing the ephemeral public keys of the initiator and responder
 * respectively as specified in sub-clause C.4.2.2.2 and C.4.2.2.3. See also section 3.7 of SEC1 [B18])
 */
static const zb_uint8_t ZB_MAC_SIZE[2] = {16,16};

/**
 * Time to generate Ephemeral KEY, need adjustment
 */
static const zb_uint8_t ZB_KEC_TIME_GEN_EPH[2] = {10,20};

/**
 * Time to confirm KEY, need adjustment
 */
static const zb_uint8_t ZB_KEC_TIME_CONFIRM_KEY[2] = {15,25};

/**
 * Size of random sequence for ephemeral key pair generation
 */
static const zb_uint8_t ZB_RND_SIZE[2] = {21,36};

#define ZB_KEC_VER 1

#define ZB_KEC_NO_RESOURCES_WAIT (20)
#define ZB_KEC_BAD_MESSAGE_WAIT (20)

/**
 * KEC cluster common attr
 * - seKeyEstablishmentSuite R const - A device shall set the corresponding bit to 1 for every cryptographic scheme that it supports.
 */

#ifdef ZB_SE_ENABLE_KEC_CLIENT
void zb_kec_client_send_request_initiate_key_establishment(zb_uint8_t param);
void zb_kec_client_send_request_finish_initiate_key_establishment(zb_uint8_t param);
#endif

/**
 * Client callback
 */
static void kec_call_user_cb(zb_uint8_t param, zb_uint16_t status);


/**
 * Server callback
 */
static void kec_call_srv_cb(zb_uint16_t addr, zb_uint8_t status);


zb_bool_t zb_zcl_process_kec_specific_commands(zb_uint8_t param);

void zb_zcl_kec_init_server()
{
  (void)zb_zcl_add_cluster_handlers(ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
                                    ZB_ZCL_CLUSTER_SERVER_ROLE,
                                    NULL,
                                    NULL,
                                    zb_zcl_process_kec_specific_commands);
#ifdef ZB_TH_ENABLED
  zse_kec_set_ch_srv_delays (0,0,0);
  KEC_CH_SKIP_MAC_CHECK = ZB_FALSE;
#endif /* ZB_TH_ENABLED */
}

void zb_zcl_kec_init_client()
{
  (void)zb_zcl_add_cluster_handlers(ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
                                    ZB_ZCL_CLUSTER_CLIENT_ROLE,
                                    NULL,
                                    NULL,
                                    zb_zcl_process_kec_specific_commands);
#ifdef ZB_TH_ENABLED
  zse_kec_set_ch_cli_delays (0,0);
#endif /* ZB_TH_ENABLED */
}

/**
 * Initialize KEC globals
 */
void zb_kec_init()
{
  ZSE_CTXC().ke.active_suites = ZB_KEC_SUPPORTED_CRYPTO_ATTR;
  ZSE_CTXC().ke.dst_ep = ZB_ZCL_BROADCAST_ENDPOINT;
  ZSE_CTXC().ke.dst_addr.addr_short = ZB_UNKNOWN_SHORT_ADDR;
  ZSE_CTXC().ke.ke_status = ZB_FALSE;

  zb_kec_cluster_nvram_init();
}


/**
 * Translate suite id into sequential crypto suite number to work with arrays
 * @param: [in] suite - cryptosuite id
 * @return: number of cryptosuite, according to passed cryptosuite id
 */
zb_uint8_t zb_kec_get_suite_num(zb_uint16_t suite)
{
  zb_uint8_t ret = 0xff;

  switch (suite)
  {
    case KEC_CS1:
      ret = 0;
      break;
    case KEC_CS2:
      ret = 1;
      break;
    default:
      TRACE_MSG(TRACE_ZSE1, "ERROR zb_kec_get_suite_num: unsupported suite passed:%hd", (FMT__H, suite));
      break;
  }
  return ret;
}


/**
 * Translate suite id into sequential crypto suite number to work with arrays
 * @param: [in] suite - cryptosuite id
 * @return: number of cryptosuite, according to passed cryptosuite id
 */
static zb_uint8_t zb_kec_get_curve_id(zb_uint16_t suite)
{
  zb_uint8_t ret = 0xff;

  switch (suite)
  {
    case KEC_CS1:
      ret =  sect163k1;
      break;
    case KEC_CS2:
      ret =  sect283k1;
      break;
    default:
      TRACE_MSG(TRACE_ZSE1, "ERROR zb_kec_get_curve_id: unsupported suite passed:%hd", (FMT__H, suite));
      break;
  }
  return ret;
}

/**
 * Internal function to reverse bytes in memory
 * @param: [in] ptr - buffer address
 * @param: [in] len - size of data to reverse
 */
static void inverse_bytes(zb_uint8_t *ptr, zb_uint32_t len)
{
  zb_uint8_t tmp;
  zb_uint32_t i;

  for(i=0; i < len / 2U; i++)
  {
    tmp = ptr[i];
    ptr[i] = ptr[len - i - 1U];
    ptr[len - i - 1U] = tmp;
  }
}

void zb_kec_load_keys_finish(zb_uint8_t param);


/**
 * Load (make a copy) and activate passed keys into local context
 *
 * @param: [in] cb_done - callback that will be executed after keys loading
 * @param  [in] param   - parameter that will be passed to @cb_done callback
 * @param: [in] suite - CryptoSuite Id
 * @param: [in] ca_public_key - Certification Authority (CA) public key
 * @param: [in] certificate - certificate, issued by CA
 * @param: [in] private_key - private key of device, issued together with certificate
 * @return: RET_OK, RET_ERROR
 */
zb_ret_t zb_kec_load_keys( zb_callback_t cb_done,
                           zb_uint8_t param,
                           zb_uint16_t suite,
                           zb_uint8_t *ca_public_key,
                           zb_uint8_t *certificate,
                           zb_uint8_t *private_key)
{
  zb_uint8_t suite_no;
  zb_uint8_t *public_reconstr_key = NULL;

  if(ZSE_CTXC().ke.kec_cb != NULL)
  {
    TRACE_MSG(TRACE_ZSE1, "zb_kec_load_keys callback busy, aborting...", (FMT__0));
    ZB_ASSERT(0);

    return RET_BUSY;
  }

  ZSE_CTXC().ke.kec_cb = cb_done;

  TRACE_MSG(TRACE_ZSE1, ">zb_kec_loadkeys:kec: suite %hd", (FMT__H, suite));

  if( (ZSE_CTXC().ke.active_suites & suite) == 0U )
  {
    TRACE_MSG(TRACE_ZSE1, "ERROR CryptoSuite with id %hd not supported", (FMT__H, suite));
    return RET_ERROR;
  }

  suite_no = zb_kec_get_suite_num(suite);

  /* Strict condition for prevention array borders violation */
  if (!ZB_KEC_VALID_SUITE_NUMBER(suite_no))
  {
    return RET_ERROR;
  }
  else
  {
    ZB_MEMCPY(&ZSE_CTXC().ke.active_certificate_authority_public_key, ca_public_key, ZB_QE_SIZE[suite_no]);
    ZB_MEMCPY(&ZSE_CTXC().ke.local_certificate, certificate, ZB_CERT_SIZE[suite_no]);
    ZB_MEMCPY(&ZSE_CTXC().ke.local_private_key, private_key, ZB_PR_SIZE[suite_no]);

    ZSE_CTXC().supported_key_suite = suite;//zb_kec_gl_active_suites;
    ZSE_CTXC().ke.ke_suite_num = suite_no;
    ZSE_CTXC().ke.local_ke_suite = suite;
    ZSE_CTXC().ke.time_generate_eph = ZB_KEC_TIME_GEN_EPH[suite_no];
    ZSE_CTXC().ke.time_confirm_key = ZB_KEC_TIME_CONFIRM_KEY[suite_no];

    ZSE_CTXC().ke.curve_id = zb_kec_get_curve_id(suite);
    zb_ecc_set_curve(ZSE_CTXC().ke.curve_id);

    if(suite == KEC_CS1)
    {
      public_reconstr_key = ZSE_CTXC().ke.local_certificate.cs1.public_reconstr_key;
    }
    if(suite == KEC_CS2)
    {
      public_reconstr_key = ZSE_CTXC().ke.local_certificate.cs2.public_reconstr_key;
    }

    ZSE_CTXC().ke.selected_ke_suite = suite;

    zb_ecc_set_curve(ZSE_CTXC().ke.curve_id);
    zb_ecc_ecqv_extraction_async(zb_kec_load_keys_finish,
                                 param,
                                 ZSE_CTXC().ke.active_certificate_authority_public_key.u8,
                                 public_reconstr_key,
                                 ZSE_CTXC().ke.local_certificate.u8,
                                 ZSE_CTXC().ke.local_public_key.u8);

    return RET_OK;
  }
}


/**
 * The last step of load keys procedure
 * @param  param - buffer reference
 */
void zb_kec_load_keys_finish(zb_uint8_t param)
{
  TRACE_MSG(TRACE_ZSE1, "zb_ecc_ecqv_extraction retval: %hd", (FMT__H, param));

  if (RET_OK != zb_ecc_get_last_error())
  {
    TRACE_MSG(TRACE_ZSE1, "<zb_kec_loadkeys:Have error in public key extraction", (FMT__0));
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "Public key extraction is finished successfully", (FMT__0));

    DUMP_TRAF("Local public_key:", (zb_uint8_t *)ZSE_CTXC().ke.local_public_key.u8, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num ], 0);

    TRACE_MSG(TRACE_ZSE1, "<zb_kec_loadkeys", (FMT__0));
  }

  if (ZSE_CTXC().ke.kec_cb != NULL)
  {
    ZB_SCHEDULE_CALLBACK(ZSE_CTXC().ke.kec_cb, param);
    ZSE_CTXC().ke.kec_cb = NULL;
  }
}


/**
 * Activate loaded keys
 *
 * @param: [in] suite - CryptoSuite Id
 * @return: RET_OK, RET_ERROR
 */
zb_ret_t zb_kec_activate_suite(zb_uint16_t suite)
{
  if((ZSE_CTXC().ke.active_suites & suite) > 0U)
  {
    zb_ret_t res;
    zb_uint8_t *public_reconstr_key = NULL;
    if(suite == KEC_CS1)
    {
      public_reconstr_key = ZSE_CTXC().ke.local_certificate.cs1.public_reconstr_key;
    }
    if(suite == KEC_CS2)
    {
      public_reconstr_key = ZSE_CTXC().ke.local_certificate.cs2.public_reconstr_key;
    }
    ZSE_CTXC().ke.selected_ke_suite = suite;

    zb_ecc_set_curve(ZSE_CTXC().ke.curve_id);
    res = zb_ecc_ecqv_extraction(ZSE_CTXC().ke.active_certificate_authority_public_key.u8, public_reconstr_key,
                                 ZSE_CTXC().ke.local_certificate.u8, ZSE_CTXC().ke.local_public_key.u8);
    TRACE_MSG(TRACE_ZSE1, "zb_ecc_ecqv_extraction retval: %hd", (FMT__H, res));
    return res;
  }
  TRACE_MSG(TRACE_ZSE1, "ERROR in zb_kec_activate_suite:kec: %hd keys not loaded", (FMT__H, suite));
  ZB_ASSERT(0);
  return RET_ERROR;
}

static zb_bool_t zb_kec_client_retry_key_establishment(zb_uint8_t param, zb_time_t wait_time);
static void zb_kec_client_initiate_key_establishment_alarm(zb_uint8_t param);

/**
 * KEC Server implementation
 *
 */
#ifdef ZB_SE_ENABLE_KEC_SERVER


/**
 * header preparation for start response command
 */
static zb_uint8_t * zb_se_kec_start_resp(zb_uint8_t param, zb_uint8_t cmd, zb_uint8_t def_resp)
{
  zb_uint8_t *ptr = ZB_ZCL_START_PACKET(param);
  ZB_ZCL_CONSTRUCT_SET_FRAME_CONTROL(*ptr, ZB_ZCL_FRAME_TYPE_CLUSTER_SPECIFIC, ZB_ZCL_NOT_MANUFACTURER_SPECIFIC, ZB_ZCL_FRAME_DIRECTION_TO_CLI, def_resp);
  ptr++;
  ZB_ZCL_CONSTRUCT_COMMAND_HEADER(ptr, ZSE_CTXC().ke.transaction_sequence_number, cmd);
  return ptr;
}


/* Do not use in any new code ZB_ZCL_FINISH_PACKET & ZB_ZCL_SEND_COMMAND_SHORT - that is compatibility with existing macro-based code.
   Call zb_zcl_finish_and_send_packet() directly instead. */
/**
 * Function to send prepared command
 */
static void zb_se_kec_finish_packet( zb_uint8_t param, zb_uint8_t *ptr, zb_zcl_parsed_hdr_t *cmd_info )
{
  zb_ret_t ret;

  ret = zb_zcl_finish_and_send_packet(
      param,
      ptr,
      /*cstat !MISRAC2012-Rule-11.3 */
      /** @mdr{00002,92} */
      (zb_addr_u *)(&(ZB_ZCL_PARSED_HDR_SHORT_DATA(cmd_info).source.u.short_addr)),
      ZB_APS_ADDR_MODE_16_ENDP_PRESENT,
      ZB_ZCL_PARSED_HDR_SHORT_DATA(cmd_info).src_endpoint,
      ZB_ZCL_PARSED_HDR_SHORT_DATA(cmd_info).dst_endpoint,
      cmd_info->profile_id,cmd_info->cluster_id, NULL );

  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_se_kec_finish_packet failed [%d]", (FMT__D, ret));
  }
}

/**
 * Function to send prepared command to partner
 */
static void zb_se_kec_finish_packet_partner_cb( zb_uint8_t param, zb_uint8_t *ptr, zb_callback_t cb )
{
  (void)zb_zcl_finish_and_send_packet(param, ptr,
  /*cstat !MISRAC2012-Rule-11.3 */
  /** @mdr{00002,93} */
      (zb_addr_u *)(&(ZSE_CTXC().ke.dst_addr.addr_short)),
      ZB_APS_ADDR_MODE_16_ENDP_PRESENT,
      ZSE_CTXC().ke.dst_ep,
      ZSE_CTXC().ke.src_ep,
      get_profile_id_by_endpoint(ZSE_CTXC().ke.src_ep),ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT, cb );
}

static void zb_se_kec_finish_packet_partner( zb_uint8_t param, zb_uint8_t *ptr )
{
  zb_se_kec_finish_packet_partner_cb( param, ptr, NULL );
}

/**
 * Function : header preparation for start request command
 */
static void *zb_se_kec_start_req( zb_uint8_t param, zb_uint8_t command, zb_uint8_t def_resp)
{
  return zb_zcl_start_command_header(param,
          ZB_ZCL_CONSTRUCT_FRAME_CONTROL(ZB_ZCL_FRAME_TYPE_CLUSTER_SPECIFIC,
          ZB_ZCL_NOT_MANUFACTURER_SPECIFIC, ZB_ZCL_FRAME_DIRECTION_TO_SRV, (def_resp)), 0, (command), NULL);
}

static void zb_kec_common_send_terminate_key_establishment_cmd_common(
            zb_uint8_t param,
            zb_bool_t to_partner,
            zb_bool_t is_server,
            zb_uint16_t addr,
            zb_uint8_t ep,
            zb_kec_term_status_t status,
            zb_uint8_t wait_time)
{
  zb_uint8_t *resp_data;
  zb_uint32_t bytes_avail;
  zb_zcl_attr_t* ke_suite_desc;
  zb_uint16_t* ke_suite;
  zb_bool_t is_manuf_specific;
  zb_uint16_t manuf_specific;

  TRACE_MSG( TRACE_ZSE1,
             "> zb_kec_common_send_terminate_key_establishment_cmd_common: status %hd",
             (FMT__H, status));

  ke_suite_desc = zb_zcl_get_attr_desc_a(ep, ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
                                         (is_server ? ZB_ZCL_CLUSTER_SERVER_ROLE : ZB_ZCL_CLUSTER_CLIENT_ROLE),
                                         ZB_ZCL_ATTR_KEY_ESTABLISHMENT_SUITE_ID);

  ZB_ASSERT(ke_suite_desc != NULL);

  ke_suite = (zb_uint16_t*)ke_suite_desc->data_p;

  TRACE_MSG( TRACE_ZSE1, "supported KE Suite %d, KE stage: %hd", (FMT__D_H, *ke_suite, ZSE_CTXC().ke.ke_stage));
  /* Construct packet header */
  resp_data = ZB_ZCL_START_PACKET(param);

  ZB_ZCL_CONSTRUCT_SET_FRAME_CONTROL(*resp_data,
    ZB_ZCL_FRAME_TYPE_CLUSTER_SPECIFIC,
    ZB_ZCL_NOT_MANUFACTURER_SPECIFIC,
    (is_server ? ZB_ZCL_FRAME_DIRECTION_TO_CLI : ZB_ZCL_FRAME_DIRECTION_TO_SRV),
    ZB_ZCL_ENABLE_DEFAULT_RESPONSE);
    resp_data++;

    is_manuf_specific = to_partner ? ZB_FALSE : ZSE_CTXC().ke.cmd_info.is_manuf_specific;
    manuf_specific = to_partner ? 0U : ZSE_CTXC().ke.cmd_info.manuf_specific;

  ZB_ZCL_CONSTRUCT_COMMAND_HEADER_EXT(
    resp_data, ZB_ZCL_GET_SEQ_NUM(),
/*  resp_data, is_server?(to_partner?ZSE_CTXC().ke.transaction_sequence_number:ZSE_CTXC().ke.cmd_info.seq_number):ZB_ZCL_GET_SEQ_NUM(), */
    is_manuf_specific,
    manuf_specific,
    (is_server ? ZB_SE_KEC_CMD_TERMINATE_KE_SERVER : ZB_SE_KEC_CMD_TERMINATE_KE_CLIENT) );

  bytes_avail = ZB_ZCL_GET_BYTES_AVAILABLE(param, resp_data,
                                           ZB_AF_SE_PROFILE_ID, ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT);
  TRACE_MSG(TRACE_ZSE3, "bytes_avail %hd", (FMT__H, bytes_avail));

  if(bytes_avail >= 4UL)
  {
    ZB_ZCL_PACKET_PUT_DATA8(resp_data, status);
    ZB_ZCL_PACKET_PUT_DATA8(resp_data, wait_time);
    ZB_ZCL_PACKET_PUT_DATA16(resp_data, ke_suite);
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "ERROR, buffer is full", (FMT__0));
    ZB_ASSERT(0);
  }

  if(to_partner)
  {
    zb_se_kec_finish_packet_partner(param, resp_data);
  }
  else
  {
    zb_se_kec_finish_packet(param, resp_data, &ZSE_CTXC().ke.cmd_info);
  }

  /* Reset current stage to initial ke stage */
  if(to_partner && is_server)
  {
    if(ZSE_CTXC().ke.ke_stage > 1U)
    {
      TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: terminate sent to client:0x%x, status: %hd calling srv_cb", (FMT__D_H, addr, status));
      kec_call_srv_cb(addr, status);
    }
    else
    {
      #ifdef SNCP_MODE
        /* to provide indication about failed CBKE when initiated by remote device */
        kec_call_srv_cb(addr, status);
      #else
        TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: terminate sent to client:0x%x, status: %hd continue without calling srv_cb", (FMT__D_H, addr, status));
      #endif
    }
  }
  else
  {
    if(ZSE_CTXC().ke.ke_stage == 0U)
    {
      if(is_server)
      {
        TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: terminate sent to client:0x%x, status: %hd continue without calling srv_cb", (FMT__D_H, addr, status));
#ifdef SNCP_MODE
        /* to provide indication about failed CBKE when initiated by remote device */
        kec_call_srv_cb(addr, status);
#else
        /*kec_call_srv_cb(addr, status);*/
#endif
      }
      else
      {
        ZB_BZERO(&ZSE_CTXC().commissioning.ke_term_info, sizeof(ZSE_CTXC().commissioning.ke_term_info));
        kec_call_user_cb(0, status);
      }
    }
  }
}

void zb_kec_server_active_key_establishment_alarm(zb_uint8_t param);

static void zb_kec_common_send_terminate_key_establishment_cmd_to_partner(zb_uint8_t param, zb_bool_t is_server, zb_kec_term_status_t status, zb_uint8_t wait_time)
{
  TRACE_MSG( TRACE_ZSE1,
             "> zb_kec_common_send_terminate_key_establishment_cmd: TO_PARTNER status %hd",
             (FMT__H, status));

  zb_kec_common_send_terminate_key_establishment_cmd_common(param, ZB_TRUE, is_server,
           ZSE_CTXC().ke.dst_addr.addr_short, ZSE_CTXC().ke.src_ep, status, wait_time);

  if(is_server)
  {
    /* Cancel alarm for Active Key Establishment */
    ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_START;
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_server_active_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }
  else
  {
    zb_uint8_t alarm_param;
    ZB_SCHEDULE_ALARM_CANCEL_AND_GET_BUF(zb_kec_client_send_request_initiate_key_establishment, ZB_ALARM_ANY_PARAM, &alarm_param);
    if (alarm_param != 0U)
    {
      zb_buf_free(alarm_param);
    }
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_client_initiate_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }

}

/**
 * Terminate Key Establishment command for both clusters
 * @param data_buf - buffer to save data to and to send to opponent
 * @param is_server - flag that it is a server or client
 * @param status - termination status enum
 * @param wait_time - wait time to pass to opponent
 */
static void zb_kec_common_send_terminate_key_establishment_cmd_to_alien(zb_uint8_t param, zb_kec_term_status_t status, zb_uint8_t wait_time)
{
  TRACE_MSG( TRACE_ZSE1,
             "> zb_kec_common_send_terminate_key_establishment_cmd: TO_ALIEN status %hd",
             (FMT__H, status));

  zb_kec_common_send_terminate_key_establishment_cmd_common(param, ZB_FALSE,
          (zb_bool_t)(ZSE_CTXC().ke.cmd_info.cmd_direction == (zb_uint8_t)ZB_ZCL_FRAME_DIRECTION_TO_SRV),
           ZSE_CTXC().ke.cmd_info.addr_data.common_data.source.u.short_addr,
           ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).dst_endpoint, status, wait_time);
}

void zb_kec_server_active_key_establishment_alarm(zb_uint8_t param)
{
  ZVUNUSED(param);
  /* Alarm already timed out, so abort key establishment immediately */
  TRACE_MSG(TRACE_ZSE1, "zb_kec_server_active_key_establishment_alarm", (FMT__0) );
  TRACE_MSG(TRACE_ZSE1, "Stage: %d with partner: %d", (FMT__D_D, ZSE_CTXC().ke.ke_stage, ZSE_CTXC().ke.dst_addr.addr_short));
  switch (ZSE_CTXC().ke.ke_stage)
  {
    case KE_STAGE_SERVER_START:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_START", (FMT__0));
      break;
    case KE_STAGE_SERVER_INITIATE_REQUEST_RECEIVED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_INITIATE_REQUEST_RECEIVED", (FMT__0));
      TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: Internal problem, terminated, calling srv_cb with status ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES", (FMT__0));
      kec_call_srv_cb(ZSE_CTXC().ke.dst_addr.addr_short, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES);
      break;
    case KE_STAGE_SERVER_INITIATE_RESPONSE_SENT:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_INITIATE_RESPONSE_SENT", (FMT__0));
      /* break to wait and stop Server\'s CBKE */
      /* C.3.1.2.3.2.2 Effect on Receipt
      If the device is in the middle of Key Establishment with the sender but did not
      receive this message in response to an Ephemeral Data Response command,
      it shall send back a Terminate Key Establishment message with a result of BAD_MESSAGE. 4081
      Test 15.24 Step 5 The TC should silently time out the key establishment operation with
      DEVx. No Terminate Key Establishment Message should be sent yet*/
      TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: terminated by timeout, do not call srv_cb", (FMT__0));
      break;
    case KE_STAGE_SERVER_EPHEMERAL_DATA_REQUEST_RECEIVED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_EPHEMERAL_DATA_REQUEST_RECEIVED", (FMT__0));
      TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: Internal problem, terminated, calling srv_cb with status ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES", (FMT__0));
      kec_call_srv_cb(ZSE_CTXC().ke.dst_addr.addr_short, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES);
      break;
    case KE_STAGE_SERVER_EPHEMERAL_DATA_RESPONSE_SENT:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_EPHEMERAL_DATA_RESPONSE_SENT", (FMT__0));
      /* C.3.1.2.3.3.2 Effect on Receipt
      If the device is in the middle of Key Establishment with the sender but did not
      receive this message in response to an Confirm Key Response command,
      it shall send back a Terminate Key Establishment message with a result of BAD_MESSAGE. 4098 */
      TRACE_MSG(TRACE_ZSE1, "KEC_SERVER: terminated by timeout, do not call srv_cb", (FMT__0));
      break;
    case KE_STAGE_SERVER_CONFIRM_KEY_REQUEST_RECEIVED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_CONFIRM_KEY_REQUEST_RECEIVED", (FMT__0));
      break;
    case KE_STAGE_SERVER_CONFIRM_KEY_RESPONSE_SENT:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_CONFIRM_KEY_RESPONSE_SENT", (FMT__0));
      ///?
      break;
    case KE_STAGE_SERVER_FINISHED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_SERVER_FINISHED", (FMT__0));
      break;
    default:
      TRACE_MSG(TRACE_ZSE1, "unknown state", (FMT__0));
      break;
  }
  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_START;
  ZSE_CTXC().ke.dst_addr.addr_short = ZB_UNKNOWN_SHORT_ADDR;
  ZSE_CTXC().ke.ke_status = ZB_FALSE;
}

/**
 * Server send this cmd: Initiate Key Establishment Response
 * The Initiate Key Establishment Response command allows a device to respond to a device
 * requesting the initiation of key establishment with it. The sender will transmit its identity
 * information and key establishment protocol information to the receiving device.
 * Payload Format
 * The Initiate Key Establishment Response command payload shall be formatted as illustrated in Figure C-8.
 *
 * @param param - input buffer for generate and send the command
 */
static void zb_kec_server_send_initiate_key_establishment_response(zb_uint8_t param)
{

  TRACE_MSG( TRACE_ZSE1, "> zb_kec_server_send_initiate_key_establishment_response", (FMT__0));

  ZSE_CTXC().ke.ke_status = ZB_TRUE;

  {
    /* Construct packet header for KEC_INITIALIZATION response command */
    zb_uint8_t i;
    zb_uint8_t *cmd_ptr = ZB_ZCL_START_PACKET(param);
    ZB_ZCL_CONSTRUCT_SPECIFIC_COMMAND_RES_FRAME_CONTROL(cmd_ptr);
    ZB_ZCL_CONSTRUCT_COMMAND_HEADER(cmd_ptr, ZSE_CTXC().ke.transaction_sequence_number, ZB_SE_KEC_CMD_INITIATE_KE_RESPONSE);
    ZB_ZCL_PACKET_PUT_DATA16_VAL(cmd_ptr, (ZSE_CTXC().ke.selected_ke_suite));
    ZB_ZCL_PACKET_PUT_DATA8(cmd_ptr, (ZSE_CTXC().ke.time_generate_eph));
    ZB_ZCL_PACKET_PUT_DATA8(cmd_ptr, (ZSE_CTXC().ke.time_confirm_key));
    for(i=0;i<(ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]);i++)
    {
      ZB_ZCL_PACKET_PUT_DATA8(cmd_ptr, *((zb_uint8_t *)(ZSE_CTXC().ke.local_certificate.u8)+i));
    }
    zb_se_kec_finish_packet_partner(param, cmd_ptr);
  }

  ZB_SCHEDULE_ALARM(zb_kec_server_active_key_establishment_alarm, 0U,
    (zb_time_t)(ZSE_CTXC().ke.remote_ephemeral_timeout + 5UL) * ZB_TIME_ONE_SECOND);

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_INITIATE_RESPONSE_SENT;
  TRACE_MSG( TRACE_ZSE1,
              "< zb_kec_server_send_initiate_key_establishment_response", (FMT__0));
}

void zb_kec_server_send_ephemeral_data_response_finish(zb_uint8_t param);


/**
 * Server send this cmd: Send Ephemeral Datal Response
 * The Initiate Key Establishment Response command allows a device to respond to a device
 * requesting the initiation of key establishment with it. The sender will transmit its identity
 * information and key establishment protocol information to the receiving device.
 * Payload Format
 * The Initiate Key Establishment Response command payload shall be formatted as illustrated in Figure C-8.
 *
 * @param param - input buffer for generate and send the command
 */
static zb_ret_t zb_kec_server_send_ephemeral_data_response(zb_callback_t cb_done, zb_uint8_t param)
{
  zb_uint8_t random[ZB_MAX_RND_SIZE];
  zb_uint8_t j;

  if(ZSE_CTXC().ke.kec_cb != NULL)
  {
    TRACE_MSG(TRACE_ZSE1, "zb_kec_load_keys callback busy, aborting...", (FMT__0));
    ZB_ASSERT(0);

    return RET_BUSY;
  }

  ZSE_CTXC().ke.kec_cb = cb_done;
  /*C.3.1.2.3.2 Ephemeral Data Request Command
  The Ephemeral Data Request command allows a device to communicate its ephemeral data
  to another device and request that the device send back its own ephemeral data. */

  for(j = 0 ; j < ZB_RND_SIZE[ZSE_CTXC().ke.ke_suite_num] ; ++j)
  {
    random[j] = (zb_uint8_t)(ZB_RANDOM_U16() >> 4) & 0xFFU;
  }
  zb_ecc_set_curve(ZSE_CTXC().ke.curve_id);
  zb_ecc_key_generation_async(zb_kec_server_send_ephemeral_data_response_finish,
                              param,
                              random,
                              ZSE_CTXC().ke.local_ephemeral_private_key.u8,
                              ZSE_CTXC().ke.local_ephemeral_public_key.u8);
  return RET_OK;
}


/**
 * The last step of sending ephemeral data response
 * @param  param - buffer reference
 */
void zb_kec_server_send_ephemeral_data_response_finish(zb_uint8_t param)
{
  zb_uint8_t *resp_ptr;
  zb_uint32_t bytes_avail;
  zb_uint8_t i;

#ifdef ZB_TH_ENABLED
  if (KEC_SRV_CH_DELAY_EPH_TIME>0) {
    ZB_SCHEDULE_ALARM(zb_kec_server_send_ephemeral_data_response_finish, param, (KEC_SRV_CH_DELAY_EPH_TIME * ZB_TIME_ONE_SECOND));
    KEC_SRV_CH_DELAY_EPH_TIME = 0;
    return;
  }
#endif /* ZB_TH_ENABLED */

  resp_ptr = zb_se_kec_start_resp(param, ZB_SE_KEC_CMD_EPHEMERAL_DATA_RESPONSE, ZB_ZCL_ENABLE_DEFAULT_RESPONSE);

  TRACE_MSG( TRACE_ZSE1, "> zb_kec_server_send_ephemeral_data_response", (FMT__0));

  bytes_avail = ZB_ZCL_GET_BYTES_AVAILABLE(param, resp_ptr,
                                           ZB_AF_SE_PROFILE_ID, ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT);
  TRACE_MSG(TRACE_ZSE3, "bytes_avail %hd", (FMT__H, bytes_avail));
  if( bytes_avail >= ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num] )
  {

    TRACE_MSG( TRACE_ZSE1, "ephemeral keys generated", (FMT__0));
    DUMP_TRAF( "private:", ZSE_CTXC().ke.local_ephemeral_private_key.u8,ZB_PR_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
    DUMP_TRAF( "public :", ZSE_CTXC().ke.local_ephemeral_public_key.u8,ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num],0);

    for (i = 0; i < ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]; i++)
    {
      ZB_ZCL_PACKET_PUT_DATA8(resp_ptr, ZSE_CTXC().ke.local_ephemeral_public_key.u8[i]); /*QEU - generate and send */
    }
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "ERROR, buffer is full", (FMT__0));
    ZB_ASSERT(0);
  }

  zb_se_kec_finish_packet_partner( param, resp_ptr );

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_EPHEMERAL_DATA_RESPONSE_SENT;

  ZB_SCHEDULE_ALARM(zb_kec_server_active_key_establishment_alarm,
    0U, (zb_time_t)(ZSE_CTXC().ke.remote_confirm_timeout + 5UL ) * ZB_TIME_ONE_SECOND);

  TRACE_MSG( TRACE_ZSE1, "< zb_kec_server_send_ephemeral_data_response", (FMT__0));

  if (ZSE_CTXC().ke.kec_cb != NULL)
  {
    ZB_SCHEDULE_CALLBACK(ZSE_CTXC().ke.kec_cb, param);  /*FIXME: what parameter do we need pass to callback?*/
    ZSE_CTXC().ke.kec_cb = NULL;
  }
}

void zb_kec_generate_remote_public_key_finish(zb_uint8_t param);


/**
 * Procedure for public key extraction from certificate for remote device
 * @param  cb_done - callback which will be called when extraction is finished
 * @param  param   - buffer reference or other parameter for passing it to @cb_done callback
 * @return         - return RET_BUSY if ecc library is already running, RET_ERROR in fail, RET_OK in success.
 */
/*FIXME:DD: need to dermine right execution order of this and shared key generation functions*/
static zb_ret_t zb_kec_generate_remote_public_key(zb_callback_t cb_done, zb_uint8_t param)
{
  zb_ret_t ret;

  if(ZSE_CTXC().ke.kec_cb != NULL)
  {
    return RET_BUSY;
  }

  ZSE_CTXC().ke.kec_cb = cb_done;

  ZSE_CTXC().ke.remote_public_key_retval = RET_BUSY;
  TRACE_MSG(TRACE_ZSE1, "> zb_kec_generate_shared_secret", (FMT__0));

  zb_ecc_set_curve(ZSE_CTXC().ke.curve_id);

  switch(ZSE_CTXC().ke.selected_ke_suite)
  {
    case KEC_CS1:
      zb_ecc_ecqv_extraction_async(zb_kec_generate_remote_public_key_finish,
                                  param,
                                  ZSE_CTXC().ke.active_certificate_authority_public_key.u8,
                                  ZSE_CTXC().ke.remote_certificate.cs1.public_reconstr_key,
                                  ZSE_CTXC().ke.remote_certificate.u8, ZSE_CTXC().ke.remote_public_key.u8);
      ret = RET_OK;
      break;
    case KEC_CS2:
      zb_ecc_ecqv_extraction_async(zb_kec_generate_remote_public_key_finish,
                                   param,
                                   ZSE_CTXC().ke.active_certificate_authority_public_key.u8,
                                   ZSE_CTXC().ke.remote_certificate.cs2.public_reconstr_key,
                                   ZSE_CTXC().ke.remote_certificate.u8, ZSE_CTXC().ke.remote_public_key.u8);
      ret = RET_OK;
      break;
    default:
      ret = RET_ERROR;
      break;
  }

  return ret;
}


/**
 * The last step of public key extraction procedure for remote device
 * @param  param - buffer reference or other parameter that will be passed to ZSE_CTXC().ke.kec_cb callback
 */
void zb_kec_generate_remote_public_key_finish(zb_uint8_t param)
{
  /*FIXME: in current implementation this value is not used*/
  ZSE_CTXC().ke.remote_public_key_retval = zb_ecc_get_last_error();

  if(RET_OK != zb_ecc_get_last_error())
  {
    TRACE_MSG(TRACE_ZSE1, "Have error in public key extraction", (FMT__0));
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "Public key extraction is finished successfully", (FMT__0));
  }

  if (ZSE_CTXC().ke.kec_cb != NULL)
  {
    ZB_SCHEDULE_CALLBACK(ZSE_CTXC().ke.kec_cb, param);
    ZSE_CTXC().ke.kec_cb = NULL;
  }
}

void zb_kec_generate_shared_secret_finish(zb_uint8_t param);


/**
 * @brief Function generates shared secret between 2 devices
 * @param cb_done - callback that will be called after shared secret generation.
 * @param param   - parameter that will be passed to to @cb_done
 * @return RET_ERROR, RET_OK, RET_BUSY
 */
static zb_ret_t zb_kec_generate_shared_secret(zb_callback_t cb_done, zb_uint8_t param)
{
  if(ZSE_CTXC().ke.kec_cb != NULL)
  {
    TRACE_MSG(TRACE_ZSE1, "zb_kec_generate_shared_secret callback busy, aborting...", (FMT__0));
    ZB_ASSERT(0);
    return RET_BUSY;
  }

  ZSE_CTXC().ke.kec_cb = cb_done;

/*DUMP_TRAF("remote_public_key:",(zb_uint8_t *)remote_public_key, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  DUMP_TRAF("local_public_key:",(zb_uint8_t *)ZSE_CTXC().ke.local_public_key, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  DUMP_TRAF("local_ephemeral_public_key:",(zb_uint8_t *)&ZSE_CTXC().ke.local_ephemeral_public_key, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  DUMP_TRAF("remote_ephemeral_public_key:",(zb_uint8_t *)&ZSE_CTXC().ke.remote_ephemeral_public_key, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  DUMP_TRAF("local_private_key:",(zb_uint8_t *)ZSE_CTXC().ke.local_private_key, ZB_PR_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  DUMP_TRAF("local_ephemeral_private_key:",(zb_uint8_t *)&ZSE_CTXC().ke.local_ephemeral_private_key, ZB_PR_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  TRACE_MSG(TRACE_ZSE3, "curve_id %hd", (FMT__H, ZSE_CTXC().ke.curve_id));*/
  zb_ecc_ecmqv_async( zb_kec_generate_shared_secret_finish,
                      param,
                      ZSE_CTXC().ke.local_private_key.u8,
                      ZSE_CTXC().ke.local_ephemeral_private_key.u8,
                      ZSE_CTXC().ke.local_ephemeral_public_key.u8,
                      ZSE_CTXC().ke.remote_public_key.u8,
                      ZSE_CTXC().ke.remote_ephemeral_public_key.u8,
                      ZSE_CTXC().ke.Z.u8);

  return RET_OK;
}


/**
 * The last step of shared key generation procedure
 * @param  param - parameter that will be passed to ZSE_CTXC().ke.kec_cb callback
 */
void zb_kec_generate_shared_secret_finish(zb_uint8_t param)
{
  if (RET_OK != zb_ecc_get_last_error())
  {
    TRACE_MSG(TRACE_ZSE1, "Shared key generation failed", (FMT__0));
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "Shared key generation is finished successfully", (FMT__0));
    DUMP_TRAF("Shared key between device 1 and device 2 is-->", ZSE_CTXC().ke.Z.u8, ZB_SK_SIZE[ZSE_CTXC().ke.ke_suite_num], 0);
  }

  if (ZSE_CTXC().ke.kec_cb != NULL)
  {
    ZB_SCHEDULE_CALLBACK(ZSE_CTXC().ke.kec_cb, param);
    ZSE_CTXC().ke.kec_cb = NULL;
  }
}

/**
 * Generate key hmac for given data
 * @param key
 * @param msg
 * @param id1
 * @param id2
 * @param key1
 * @param key2
 * @param mac
 */
static void zb_kec_generate_mac(zb_uint8_t *key,
                                zb_uint8_t msg,
                                zb_uint8_t *id1,
                                zb_uint8_t *id2,
                                zb_uint8_t *key1,
                                zb_uint8_t *key2,
                                zb_uint8_t *mac)
{
  zb_uint8_t *p, i;
  zb_uint8_t pub_size = ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num];
  zb_uint8_t m_size = 2U * 8U + pub_size * 2U + 1U;
  zb_uint8_t m[91];
  zb_bufid_t hash = SEC_CTX().encryption_buf;

  /* MISRA Rule 16.6
   * There were no real case clauses in the previous 'switch-case' statement. Removed it as it had
   * no real function here. */

  p = m;
  *p++ = msg;
  for (i = 0U; i < 8U; i++)
  {
    *p++ = id1[i];
  }
  for (i = 0U; i < 8U; i++)
  {
    *p++ = id2[i];
  }
  for (i = 0; i < pub_size; i++)
  {
    *p++ = key1[i];
  }
  for (i = 0; i < pub_size; i++)
  {
    *p++ = key2[i];
  }
  DUMP_TRAF("MESSAGE:", m, m_size, 0);
  zb_ecc_key_hmac(key, m, m_size, hash);
  ZB_MEMCPY(mac, zb_buf_begin(hash), 16);
}


/**
 * Generate full keying data for given shared secret
 *
 * @param Z - given shared key
 * @param mac_key - mac_key for produce macv, macu - secure message authentication code
 * @param key_data - key_data - to encrypt data traffic (link key)
 *
 */
static void zb_kec_generate_keyingdata(zb_uint8_t *Z, zb_uint8_t *mac_key, zb_uint8_t *key_data)
{
  zb_uint8_t i[ZB_KEC_MAX_SHARED_KEY_SIZE+4U];
  zb_uint32_t sk_size = ZB_SK_SIZE[ZSE_CTXC().ke.ke_suite_num];
  zb_bool_t ret;

  TRACE_MSG(TRACE_ZSE1, "> zb_kec_generate_keyingdata", (FMT__0));
  DUMP_TRAF("Shared_secret:", Z, ZB_SK_SIZE[ZSE_CTXC().ke.ke_suite_num], 0);

  ZB_MEMCPY(i, Z, sk_size);
  i[sk_size]   = 0;
  i[sk_size+1UL] = 0;
  i[sk_size+2UL] = 0;
  i[sk_size+3UL] = 1;
  ret = zb_sec_b6_hash(i, sk_size+4UL, mac_key);
  ZB_ASSERT(ret == ZB_TRUE);
  DUMP_TRAF("mac_key:", mac_key, ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num], 0);

  i[sk_size+3UL] = 2;
  ret = zb_sec_b6_hash(i, sk_size+4UL, key_data);
  ZB_ASSERT(ret == ZB_TRUE);
#ifdef ZB_SE_KEC_FAKE_KEY
  {
    zb_uint8_t mkey[] = {0x5A, 0x69, 0x67, 0x42, 0x65, 0x65, 0x41, 0x6C, 0x6C, 0x69, 0x61, 0x6E, 0x63, 0x65, 0x30, 0x39};
    ZB_MEMCPY(key_data, mkey, sizeof(mkey));
  }
#endif
  DUMP_TRAF("key_data:", key_data, ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num], 0);
}


/**
 *
 * Server send this cmd: Confirm Key Response
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_server_send_confirm_key_response(zb_uint8_t param)
{
  zb_uint32_t bytes_avail;
  zb_uint8_t macv[ZB_ECC_HASH_LEN];
  zb_uint8_t *resp_ptr;
  zb_uint8_t *remote_id = NULL;
  zb_ieee_addr_t ieee_addr;

#ifdef ZB_TH_ENABLED
  if (KEC_SRV_CH_DELAY_CNF_TIME>0) {
    ZB_SCHEDULE_ALARM(zb_kec_server_send_confirm_key_response, param, (KEC_SRV_CH_DELAY_CNF_TIME * ZB_TIME_ONE_SECOND));
    KEC_SRV_CH_DELAY_CNF_TIME = 0;
    return;
  }
#endif /* ZB_TH_ENABLED */

  resp_ptr = zb_se_kec_start_resp(param, ZB_SE_KEC_CMD_CONFIRM_KEY_RESPONSE, ZB_ZCL_ENABLE_DEFAULT_RESPONSE);

  TRACE_MSG( TRACE_ZSE1, "> zb_kec_server_send_confirm key_response", (FMT__0));

  bytes_avail = ZB_ZCL_GET_BYTES_AVAILABLE(param, resp_ptr,
                                           ZB_AF_SE_PROFILE_ID, ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT);
  TRACE_MSG(TRACE_ZSE3, "bytes_avail %hd", (FMT__H, bytes_avail));
  if( bytes_avail >= ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num] )
  {
    zb_uint8_t i;
/*C.3.1.3.3.3  Confirm Key Response  Command
The Confirm Key  Response command  allows  the  responder  to  verify  the  initiator has derived the
same secret key . This is done by sending the initiator a cryptographic  hash  generated  using  the
keying  material  and  the  identities  and ephemeral data of both parties.
C.3.1.3.3.3.1  Payload  Format
The Confirm Key  Response command payload shall be formatted as illustrated in Figure C-10. */
    if( KEC_CS1 == ZSE_CTXC().ke.selected_ke_suite )
    {
      remote_id = ZSE_CTXC().ke.remote_certificate.cs1.subject;
    }
    if( KEC_CS2 == ZSE_CTXC().ke.selected_ke_suite )
    {
      remote_id = ZSE_CTXC().ke.remote_certificate.cs2.subject;
    }

    /* WARNING: IEEE has reverse byte order. */
    ZB_IEEE_ADDR_COPY(ieee_addr, ZB_PIBCACHE_EXTENDED_ADDRESS());
    inverse_bytes(ieee_addr, 8);

    zb_kec_generate_mac(ZSE_CTXC().ke.mac_key, 0x03, /* ZB_PIBCACHE_EXTENDED_ADDRESS() */ieee_addr, remote_id,
                        ZSE_CTXC().ke.local_ephemeral_public_key.u8, ZSE_CTXC().ke.remote_ephemeral_public_key.u8, macv);
    DUMP_TRAF( "macv:", macv,16,0);

    for (i = 0; i < ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num]; i++)
    {
      ZB_ZCL_PACKET_PUT_DATA8(resp_ptr, macv[i]); /* macv - secure message authentication code */
    }
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "ERROR, buffer is full", (FMT__0));
    ZB_ASSERT(0);
  }

  zb_se_kec_finish_packet_partner( param, resp_ptr );

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_CONFIRM_KEY_RESPONSE_SENT;
}
/*
void zb_kec_send_to_partner(void)
{
  ZB_MEMCPY(&ZSE_CTXC().ke.cmd_info, &ZSE_CTXC().ke.partner_cmd_info, sizeof(zb_zcl_parsed_hdr_t));
}
*/
static zse_cert_nvram_t b;

/**
 * Handlers of request commands
 */

void zb_kec_server_handle_initiate_key_establishment_request_finish(zb_uint8_t param);

/**
 *
 * Server handler for Initiate Key Establishment request
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_server_handle_initiate_key_establishment_request(zb_uint8_t param)
{
  zb_uint16_t req_ke_suite;
  zb_zcl_attr_t *ke_suite_desc;
  zb_uint16_t ke_suite;
  zb_uint8_t *t_issuer;
  zse_cert_nvram_t *existing_cert;
  zb_kec_init_ke_req_cmd_t *ke_req = (zb_kec_init_ke_req_cmd_t *)zb_buf_begin(param);
  zb_ieee_addr_t src_ieee_addr;
  zb_aps_device_key_pair_set_t *aps_key;

  TRACE_MSG( TRACE_ZSE1,
             "> zb_kec_server_handle_initiate_key_establishment_request: param %hd", (FMT__H, param));

  req_ke_suite = ke_req->ke_suite;

  if(ZSE_CTXC().ke.ke_stage != KE_STAGE_SERVER_START)
  {
    TRACE_MSG( TRACE_ZSE1, "Stage not suitable for initiate_key_establishment_request command:kec: state %d - send WAIT",
               (FMT__D, ZSE_CTXC().ke.ke_stage));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    //zb_buf_free(param);
    return;
/*FIXME:AEV:What to do if packet arrived during other ke session in progress - DROP*/
  }

  /*
    CBKE between non TC is only accepted if both non-TC share a partner LK
    If we are TC, request for non TC devices are accepted without checking for LK on our side
    If request comes from TC it is always accepted even if we do not have a LK
  */
  {
    zb_ret_t ret;
    ret = zb_address_ieee_by_short(ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr, src_ieee_addr);
    ZB_ASSERT(ret == RET_OK);
  }

  if (!ZB_IS_TC() && !ZB_IEEE_ADDR_CMP(ZB_AIB().trust_center_address, src_ieee_addr))
  {
    aps_key = zb_secur_get_link_key_by_address(src_ieee_addr, ZB_SECUR_VERIFIED_KEY);

    if (aps_key == NULL
        || aps_key->key_source != ZB_SECUR_KEY_SRC_CBKE
#if defined ZB_SE_KE_WHITELIST
        /*  Conditions to check for a LK are the same to check the whitelist. */

        /*cstat !MISRAC2012-Rule-13.5 */
        /* After some investigation, the following violation of Rule 13.5 seems to be
         * a false positive. There are no side effect to zb_aib_trust_center_address_cmp(). This
         * violation seems to be caused by the fact that zb_aib_trust_center_address_cmp() is an
         * external function, which cannot be analyzed by C-STAT. */
        || (zb_secur_search_ke_whitelist(src_ieee_addr) == RET_NOT_FOUND)
#endif
    )
    {
      zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES,
                                                                  ZB_KEC_NO_RESOURCES_WAIT);
      return;
    }
  }

/* Check for only 1 bit set in the suite requested */
  if( zb_bit_cnt16(req_ke_suite) != 1U )
  {
    TRACE_MSG( TRACE_ZSE1, "Requested suite not 1 bit set check:kec: requested suite %d",
               (FMT__D, req_ke_suite));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

/* Check suite supported */
  ke_suite_desc = zb_zcl_get_attr_desc_a(
    ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).dst_endpoint,
    ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
    ZB_ZCL_CLUSTER_SERVER_ROLE,
    ZB_ZCL_ATTR_KEY_ESTABLISHMENT_SUITE_ID);

  ZB_ASSERT(ke_suite_desc != NULL);

  ke_suite = *(zb_uint16_t*)ke_suite_desc->data_p;

  if( (req_ke_suite & ke_suite) == 0U )
  {
    TRACE_MSG( TRACE_ZSE1, "Unsupported suite:kec: requested suite %d, supported suite %d",
               (FMT__D_D, req_ke_suite, ke_suite));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNSUPPORTED_SUITE, 0);
    return;
  }
  else
  {
    TRACE_MSG( TRACE_ZSE1, "Supported suite:kec: requested suite %d, supported suite %d",
               (FMT__D_D, req_ke_suite, ke_suite));
  }
/* request received, continue processing */
  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_INITIATE_REQUEST_RECEIVED;
  ZSE_CTXC().ke.src_ep = ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).dst_endpoint;
  ZSE_CTXC().ke.dst_ep = ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).src_endpoint;
  ZSE_CTXC().ke.dst_addr.addr_short = ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr;

  ZSE_CTXC().ke.remote_ke_suite = req_ke_suite;

/* For all future server messages within the current key establishment negotiation, the Key
Establishment suite value received in this message shall be utilized. */
  ZSE_CTXC().ke.selected_ke_suite = req_ke_suite;
  ZSE_CTXC().ke.ke_suite_num = zb_kec_get_suite_num(req_ke_suite);

  TRACE_MSG( TRACE_ZSE1, "Ephemeral data generate time %d", (FMT__D, ke_req->eph_data_gen_time));
  TRACE_MSG( TRACE_ZSE1, "Confirm Key generate time %d", (FMT__D, ke_req->conf_key_gen_time));

  ZSE_CTXC().ke.transaction_sequence_number = ZSE_CTXC().ke.cmd_info.seq_number;

  if((ke_req->eph_data_gen_time>254U) || (ke_req->conf_key_gen_time>254U))
  {
    TRACE_MSG( TRACE_ZSE1, "Unsupported gen_time out of boundaries:kec:", (FMT__0));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  ZSE_CTXC().ke.remote_ephemeral_timeout = ke_req->eph_data_gen_time;
  ZSE_CTXC().ke.remote_confirm_timeout = ke_req->conf_key_gen_time;

/* Check resources
   FIXME:AEV - single threaded yet, maybe check resources later, time set also */

/*Check Issuer - scan database of certificates, exit if not found*/
  t_issuer = NULL;
  if(req_ke_suite == KEC_CS1 )
  {
    t_issuer = (zb_uint8_t *)&ke_req->idu.cs1.issuer;
  }
  if(req_ke_suite == KEC_CS2 )
  {
    t_issuer = (zb_uint8_t *)&ke_req->idu.cs2.issuer;
  }

  DUMP_TRAF( "Issuer field:", t_issuer,8,0);
  TRACE_MSG( TRACE_ZSE1, "Issuer of incoming cert: " TRACE_FORMAT_64, (FMT__A, TRACE_ARG_64(t_issuer)));

  ZB_ASSERT(t_issuer);

  existing_cert = zse_certdb_get_from_tc_storage(ZSE_CTXC().ke.ke_suite_num, t_issuer, &b);
  if(existing_cert == NULL)
  {
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd (from 0) issuer " TRACE_FORMAT_64 " not found in certdb", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( t_issuer )));
    if(b.suite_no != 0xFFU)
    {
      TRACE_MSG( TRACE_ERROR, "ERROR: No any certificate found for suite %d, but ZCL ATTRIBUTE KEY_ESTABLISHMENT_SUITE_ID included this suite, please fix attribute value or load certificate for suite %d", (FMT__H_H, req_ke_suite, req_ke_suite));
    }
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNKNOWN_ISSUER, 0);
    return;
  }

  /*NOTE: zb_ecc_load_keys can return ZB_BUSY*/
  if ( RET_ERROR == zb_kec_load_keys( zb_kec_server_handle_initiate_key_establishment_request_finish,
                                      param, req_ke_suite, b.ca.u8, b.cert.u8, b.pr.u8 ) )
  {
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd (from 0) issuer " TRACE_FORMAT_64 " found but it is broken", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( t_issuer )));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE, 0);
    return;
  }
  //return;
  //}
  //FIXME: This call will be triggered if previous if-statement do not trigger
  //zb_kec_server_handle_initiate_key_establishment_request_finish(RET_OK);
}


/**
 * The intermediate step of key establishment request initiation
 * @param  param - buffer reference
 */
void zb_kec_server_handle_initiate_key_establishment_request_finish(zb_uint8_t param)
{
  zb_ieee_addr_t remote_addr;
  zb_kec_init_ke_req_cmd_t *ke_req = (zb_kec_init_ke_req_cmd_t *)zb_buf_begin(param);
  zb_uint8_t *remote_id = NULL;
  zb_uint8_t *t_issuer;

  //FIXME:DD: get t_issuer again
  t_issuer = (KEC_CS1 == ZSE_CTXC().ke.selected_ke_suite) ? (zb_uint8_t *)&ke_req->idu.cs1.issuer : (zb_uint8_t *)&ke_req->idu.cs2.issuer;

  if ( RET_OK != zb_ecc_get_last_error())
  {
    ZVUNUSED(t_issuer);
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd issuer " TRACE_FORMAT_64 " found but it is broken", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( t_issuer )));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE, 0);
    return;
  }

  if ( ZSE_CTXC().ke.selected_ke_suite == KEC_CS1 )
  {
    //TRACE_MSG( TRACE_ZSE1, "Identity field: %02x", (FMT__D, ke_req->idu.cs1.issuer[0]));
    remote_id = (zb_uint8_t *)&ke_req->idu.cs1.subject;
  }
  if ( ZSE_CTXC().ke.selected_ke_suite == KEC_CS2 )
  {
/* C.3.1.2.3.1.2  Effect on Receipt
If the implicit certificate received in the message is for the Crypto Suite 2 Cipher Suite, then
the receiving device shall check the status of the KeyUsage field and, if the Key Agreement
flag is NOT set, shall send a Terminate Key Establishment message with the status of INVALID_CERTIFICATE.
The receiving device shall also check the Type, Curve and Hash fields of
such a certificate, and send a Terminate Key Establishment message with the status of
INVALID_CERTIFICATE if any of these fields contains an invalid value.*/
    if((!IS_KEC_KEY_AGREEMENT_FLAG(ke_req->idu.cs2.key_usage))
       || (ke_req->idu.cs2.type !=0x00U)
       || (ke_req->idu.cs2.curve !=0x0DU)
       || (ke_req->idu.cs2.hash !=0x08U))
    {
      TRACE_MSG( TRACE_ZSE1, "kec:CS2:if(!IS_KEC_KEY_AGREEMENT_FLAG(ke_req->idu.cs2.key_usage)) key_usage:%02x or types failed", (FMT__D, ke_req->idu.cs2.key_usage));
      zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE, 0);
      return;
    }
    remote_id = (zb_uint8_t *)&ke_req->idu.cs2.subject;
  }
/* The device should verify the certificate belongs to the address that the device is communicating with.
The binding between the identity of the communicating device and its address is verifiable using
an out-of-band method.*/
  if(zb_address_ieee_by_short(ZSE_CTXC().ke.dst_addr.addr_short, remote_addr) == RET_OK)
  {
    inverse_bytes(remote_addr, 8);
  }

  if((( ZB_MEMCMP(remote_addr, remote_id, 8) == 0 )))
  {
      //DUMP_TRAF( "Remote ieee addr:", remote_addr,8,0);
  }
  else
  {
    DUMP_TRAF( "Remote ieee addr:", remote_addr,8,0);
    DUMP_TRAF( "Remote id:", remote_id,8,0);
    TRACE_MSG( TRACE_ZSE1, "kec:certificate and device address mismatch: cert:0x%08x src:0x%08x", (FMT__D_D, remote_id, remote_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, 0);
    return;
  }
  TRACE_MSG( TRACE_ZSE1, "ke_suite_num=%d", (FMT__D, ZSE_CTXC().ke.ke_suite_num));
  if((ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]+4u) > (zb_uint8_t)zb_buf_len(param))
  {
    TRACE_MSG( TRACE_ZSE1, "ke_remote_certificate expected len=%d > current len=%d, terminate",
             ( FMT__D_D, ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num], zb_buf_len(param)-4 ) );
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, 0);
    return;
  }
  ZB_MEMCPY(&ZSE_CTXC().ke.remote_certificate, &ke_req->idu, ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]);
/* If the device accepts the request it shall send an Initiate Key Establishment Response
 command containing its own identity information.*/
#ifdef ZB_TH_ENABLED
  if (KEC_SRV_CH_DELAY_IKE_TIME>0) {
    ZB_SCHEDULE_ALARM(zb_kec_server_send_initiate_key_establishment_response, param, (KEC_SRV_CH_DELAY_IKE_TIME * ZB_TIME_ONE_SECOND));
    KEC_SRV_CH_DELAY_IKE_TIME = 0;
  } else
#endif /* ZB_TH_ENABLED */
  zb_kec_server_send_initiate_key_establishment_response(param);
}


/**
 *
 * Server handler for Ephemeral data request command
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_server_handle_ephemeral_data_request(zb_uint8_t param)
{
  zb_ret_t ret;
  zb_kec_eph_data_req_cmd_t *ephemeral_data_qeu = (zb_kec_eph_data_req_cmd_t *)zb_buf_begin(param);

/* C.3.1.2.3.2.2  Effect on Receipt
   If the device is not currently in the middle of negotiating Key Establishment with the sending
   device when it receives this  message, it shall send back a Terminate Key Establishment
   message with a result of BAD_MESSAGE.
   If the device is in the middle of Key Establishment
   with the sender but did not receive this message in response to an Initiate Key Establishment
   Response command, it shall send back a Terminate Key Establishment message with a result of
   BAD_MESSAGE.*/
  if( ZSE_CTXC().ke.ke_stage != KE_STAGE_SERVER_INITIATE_RESPONSE_SENT )
  {
    TRACE_MSG( TRACE_ZSE1, "Stage not suitable for ephemeral data request command:kec: state %d",
               (FMT__D, ZSE_CTXC().ke.ke_stage));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Ephemeral packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  /* The length of the frame shall correlate to the current key establishment suite that has been negotiated by
  the client and server (refer to Table C-14 for relevant sizes). If the data is shorter than the expected
  length  according  to the  cryptographic suite, the responder shall send back a Terminate Key
  Establishment message with a result of BAD_MESSAGE.*/
  if( zb_buf_len(param)<ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num] )
  {
    TRACE_MSG( TRACE_ZSE1, "Frame is too small to contain full ephemeral key %d, return with terminate",
    (FMT__D, zb_buf_len(param)));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  /* Received correct response - cancel alarm for Active Key Establishment */
  {
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_server_active_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_EPHEMERAL_DATA_REQUEST_RECEIVED;

  ZB_MEMCPY((zb_uint8_t *)(&ZSE_CTXC().ke.remote_ephemeral_public_key), ephemeral_data_qeu, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]);

  ZSE_CTXC().ke.transaction_sequence_number = ZSE_CTXC().ke.cmd_info.seq_number;

/*  If the device can process the request it shall respond by generating its
  own ephemeral data and sending an Ephemeral Data Response command containing that value.*/
  ret = zb_kec_server_send_ephemeral_data_response(NULL, param);//FIXME:DD
  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_kec_generate_remote_public_key failed [%d]", (FMT__D, ret));
    ZB_ASSERT(0);
  }
}

void zb_kec_srv_hdl_conf_key_req_continue(zb_uint8_t param);

void zb_kec_srv_hdl_conf_key_req_finish(zb_uint8_t param);


/**
 *
 * Server handler for Handle Confirm Key request
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_server_handle_confirm_key_request(zb_uint8_t param)
{
  zb_ret_t ret;
/**
 * C.3.1.2.3.3.2  Effect on Receipt
 * If the device is not currently in the middle of negotiating Key Establishment with the sending
 * device when it receives this message, it shall send back a Terminate Key Establishment
 * message with a result of BAD_MESSAGE. If the device is in the middle of Key Establishment
 * with the sender but did not receive this message in response  o an Ephemeral Data Response
 * command, it shall send back a Terminate Key Establishment message with a result of
 * BAD_MESSAGE.
 */
  if( ZSE_CTXC().ke.ke_stage != KE_STAGE_SERVER_EPHEMERAL_DATA_RESPONSE_SENT )
  {
    TRACE_MSG( TRACE_ZSE1, "Stage not suitable for key data request command:kec: state %d",
              (FMT__D, ZSE_CTXC().ke.ke_stage));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Confirm key packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  /* Received correct response - cancel alarm for Active Key Establishment request */
  {
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_server_active_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }
  /**
   * On receipt of the Confirm Key Request command the responder device shall compare the
   * received MACU value with its own reconstructed version of MACU. If the two match the
   * responder shall send back MACV by generating an appropriate Confirm Key Response
   * command. If the two do not match, the responder shall send back a Terminate Key
   * Establishment with a result of BAD KEY_CONFIRM and terminate the key establishment.
   */

  ZSE_CTXC().ke.transaction_sequence_number = ZSE_CTXC().ke.cmd_info.seq_number;

  /*FIXME:DD follow function can return ZB_BUSY*/
  ret = zb_kec_generate_remote_public_key(zb_kec_srv_hdl_conf_key_req_continue, param);
  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_kec_generate_remote_public_key failed [%d]", (FMT__D, ret));
    ZB_ASSERT(0);
  }
}


/**
 * The intermediate step of key request confirmation
 * @param  param - buffer reference
 */
void zb_kec_srv_hdl_conf_key_req_continue(zb_uint8_t param)
{
  zb_ret_t ret;

  ret = zb_ecc_get_last_error();
  if (ret == RET_ERROR)
  {
    /* NOTE: if cannot generate return with error no info in spec what to do in this case */
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }
  // if (RET_ERROR == zb_ecc_get_last_error())
  // {
  //   // zb_kec_srv_hdl_conf_key_req_finish(param);
  //   ZB_SCHEDULE_CALLBACK(zb_kec_srv_hdl_conf_key_req_finish, param);
  //   return;
  // }

  /*FIXME:DD follow function can return RET_BUSY*/
  ret = zb_kec_generate_shared_secret(zb_kec_srv_hdl_conf_key_req_finish, param);
  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_kec_generate_shared_secret failed [%d]", (FMT__D, ret));
    ZB_ASSERT(0);
  }
}


/**
 * The last step of key request confirmation
 * @param  param - buffer reference
 */
void zb_kec_srv_hdl_conf_key_req_finish(zb_uint8_t param)
{
  zb_uint8_t macx[ZB_ECC_HASH_LEN];
  zb_uint8_t *macu = zb_buf_begin(param);
  zb_uint8_t *remote_id = NULL;
  zb_ieee_addr_t ieee_addr;
  zb_uint16_t addr = ZSE_CTXC().ke.cmd_info.addr_data.common_data.source.u.short_addr;

  if (RET_ERROR == zb_ecc_get_last_error())
  {
    /* NOTE: if cannot generate return with error no info in spec what to do in this case */
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_CONFIRM_KEY_REQUEST_RECEIVED;

  DUMP_TRAF("Shared_secret:", ZSE_CTXC().ke.Z.u8, ZB_SK_SIZE[ZSE_CTXC().ke.ke_suite_num], 0);
  zb_kec_generate_keyingdata(ZSE_CTXC().ke.Z.u8, ZSE_CTXC().ke.mac_key, ZSE_CTXC().ke.key_data);

  if( KEC_CS1 == ZSE_CTXC().ke.selected_ke_suite )
  {
    remote_id = ZSE_CTXC().ke.remote_certificate.cs1.subject;
  }
  if( KEC_CS2 == ZSE_CTXC().ke.selected_ke_suite )
  {
    remote_id = ZSE_CTXC().ke.remote_certificate.cs2.subject;
  }

  /* WARNING: IEEE has reverse byte order. */
  ZB_IEEE_ADDR_COPY(ieee_addr, ZB_PIBCACHE_EXTENDED_ADDRESS());
  inverse_bytes(ieee_addr, 8);

  zb_kec_generate_mac(ZSE_CTXC().ke.mac_key, 0x02, remote_id, /* ZB_PIBCACHE_EXTENDED_ADDRESS() */ieee_addr,
                      ZSE_CTXC().ke.remote_ephemeral_public_key.u8, ZSE_CTXC().ke.local_ephemeral_public_key.u8, macx);
  DUMP_TRAF( "macx:", macx,16,0);
  DUMP_TRAF( "macu:", macu,16,0);

#ifdef ZB_TH_ENABLED
  if(!KEC_CH_SKIP_MAC_CHECK)
  {
#endif
  if(ZB_MEMCMP(macx, macu, ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num]) != 0)
  {
    TRACE_MSG( TRACE_ZSE1, "macu not equal to macx calculated locally, terminate KE", (FMT__0));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM, 0);
    return;
  }
#ifdef ZB_TH_ENABLED
  }
  else
  {
    TRACE_MSG( TRACE_ZSE1, "macu not equal to macx calculated locally, SKIP_MAC_CHECK", (FMT__0));
    KEC_CH_SKIP_MAC_CHECK = ZB_FALSE;
  }
#endif

  zb_kec_server_send_confirm_key_response(param);

  {
    if( ZSE_CTXC().ke.selected_ke_suite == KEC_CS1 )
    {
      remote_id = (zb_uint8_t *)&ZSE_CTXC().ke.remote_certificate.cs1.subject;
    }

    if( ZSE_CTXC().ke.selected_ke_suite == KEC_CS2 )
    {
      remote_id = (zb_uint8_t *)&ZSE_CTXC().ke.remote_certificate.cs2.subject;
    }

    /* WARNING: IEEE has reverse byte order. */
    ZB_IEEE_ADDR_COPY(ieee_addr, remote_id);
    inverse_bytes(ieee_addr, 8);

    TRACE_MSG( TRACE_ERROR, "KEC: Update key for " TRACE_FORMAT_64, (FMT__A, TRACE_ARG_64( ieee_addr )));
    TRACE_MSG( TRACE_ERROR, "TC side of CBKE - APS key: " TRACE_FORMAT_128, (FMT__B, TRACE_ARG_128(ZSE_CTXC().ke.key_data)));

    (void)zb_secur_update_key_pair(ieee_addr, (zb_uint8_t*) ZSE_CTXC().ke.key_data, ZB_SECUR_UNIQUE_KEY, ZB_SECUR_VERIFIED_KEY, ZB_SECUR_KEY_SRC_CBKE);
#if defined TC_SWAPOUT && defined ZB_COORDINATOR_ROLE
    if (ZB_IS_TC())
    {
      /* Indicate to the app that new verified key is create - time to backup */
      zb_tcsw_key_added();
    }
#endif
  }
  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_FINISHED;

  kec_call_srv_cb(addr, RET_OK);

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_START;
}


/**
 *
 * Server handler for Terminate Key Establishment command
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_server_handle_terminate_key_establishment_cmd(zb_uint8_t param)
{
  zb_kec_term_cmd_t *term_info = (zb_kec_term_cmd_t *)zb_buf_begin(param);
  zb_uint16_t addr = ZSE_CTXC().ke.cmd_info.addr_data.common_data.source.u.short_addr;

  TRACE_MSG( TRACE_ZSE1, "zb_kec_terminate_key_establishment_req:kec: status %hd wait_time %hd, key_suite %hd",
          (FMT__H_H_H, term_info->status_code,term_info->wait_time,term_info->key_suite));

  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Terminate packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return;
  }

  /* Received some response - cancel alarm for Active Key Establishment */
  {
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_server_active_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }

  ZSE_CTXC().ke.ke_stage = KE_STAGE_SERVER_START;
  ZSE_CTXC().ke.dst_addr.addr_short = ZB_UNKNOWN_SHORT_ADDR;

  switch ( term_info->status_code )
  {
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE:
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES:
/*  C.3.1.2.3.4.2  Effect on Receipt
    On receipt of the Terminate Key Establishment command the device shall terminate key
    establishment with the sender. If the device receives a status of BAD_MESSAGE or
    NO_RESOURCES it shall wait at least the time specified in the Wait Time field before trying to
    re-initiate Key Establishment with the device.
FIXME:AEV:TODO:Wait and retry schedule*/
    break;
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNSUPPORTED_SUITE:
/*  If the device receives a status of UNSUPPORTED_SUITE it should examine the
    KeyEstablishmentSuite field to determine if another suite can be used that is supported by
    the partner device. It may re-initiate key establishment using that one of the supported suites
    after waiting the amount of time specified in the Wait Time field. If the device does not
    support any of the types in the KeyEstablishmentSuite field, it should not attempt key
    establishment again with that device.
FIXME:AEV:TODO:if initiator - reinitiate with another suite*/
    break;
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM:
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNKNOWN_ISSUER:
/*  If the device receives a status of UNKNOWN_ISSUER or BAD_KEY_CONFIRM the device should not attempt
    key establishment again with the device, as it is unlikely that another attempt will be successful.
    */
    break;
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE:

    break;
    default:
      TRACE_MSG( TRACE_ZSE1, "zb_kec_terminate_key_establishment_req:unknown status:kec: status %h",
              (FMT__H, term_info->status_code));
    break;
  }
  zb_buf_free(param);

  kec_call_srv_cb(addr, term_info->status_code);
}

/**
 *
 * Server commands handler/processor
 *
 * @param param - buffer reference with input command
 *
 */
static zb_bool_t zb_zcl_process_kec_server_specific_commands(zb_uint8_t param)
{
  zb_bool_t processed = ZB_TRUE;

  ZB_ZCL_COPY_PARSED_HEADER(param, &ZSE_CTXC().ke.cmd_info);

  TRACE_MSG( TRACE_ZSE1, "> zb_zcl_process_kec_server_specific_commands: param %hd", (FMT__H, param) );

  TRACE_MSG( TRACE_ZSE1, "Current KE Stage %hd", (FMT__H, ZSE_CTXC().ke.ke_stage));

  if ((zb_bool_t)(ZSE_CTXC().ke.ke_stage > 0U) && (ZSE_CTXC().ke.ke_status == 0U)) /* no server exchange active */
  {
    TRACE_MSG(TRACE_ZSE3, "Server not active, drop server command and send no_resources to alien", (FMT__0));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return ZB_TRUE;
  }

  switch (ZSE_CTXC().ke.cmd_info.cmd_id)
  {
    case ZB_SE_KEC_CMD_INITIATE_KE_REQUEST:
      zb_kec_server_handle_initiate_key_establishment_request(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_INITIATE_KE_REQUEST command", (FMT__0));

      break;
    case ZB_SE_KEC_CMD_EPHEMERAL_DATA_REQUEST:
      zb_kec_server_handle_ephemeral_data_request(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_EPHEMERAL_DATA_REQUEST command", (FMT__0));

      break;
    case ZB_SE_KEC_CMD_CONFIRM_KEY_REQUEST:
      zb_kec_server_handle_confirm_key_request(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_CONFIRM_KEY_REQUEST command", (FMT__0));

      break;
    case ZB_SE_KEC_CMD_TERMINATE_KE_CLIENT:
      zb_kec_server_handle_terminate_key_establishment_cmd(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_TERMINATE_KE_CLIENT command", (FMT__0));

      break;
    default:
      processed = ZB_FALSE;
      break;
  }
  if(!processed)
  {
    (void)zb_zcl_send_default_handler(param, &ZSE_CTXC().ke.cmd_info, ZB_ZCL_STATUS_FAIL);
    processed = ZB_TRUE;
  }
  else
  {
      //TRACE_MSG(TRACE_ZSE3, "Unprocessed command:%hd", (FMT__H, cmd_info.cmd_id));
      //ZB_ASSERT(0);
  }

  TRACE_MSG(TRACE_ZSE1,
            "< zb_zcl_process_kec_server_specific_commands: processed %d",
            (FMT__D, processed));

  return processed;
}

#endif /* ZB_SE_ENABLE_KEC_SERVER */

/**
 * KEC Client implementation
 *
 */
#ifdef ZB_SE_ENABLE_KEC_CLIENT


/**
 * Client send this cmd : Initiate Key Establishment Request
 * C.3.1.2.3.1  Initiate Key Establishment Request Command
 * The  Initiate  Key  Establishment  Request  command  allows  a  device  to  initiate  key establishment
 * with  another  device.  The  sender  shall  indicate  the  identity  information  and  key  establishment
 * protocol information  that it wishes to use to the receiving device.
 * C.3.1.2.3.1.1  Payload  Format
 * The  Initiate  Key  Establishment  Request  command  payload  shall  be  formatted  as illustrated in Figure C-4.
 *
 * @param param - output buffer reference to send command
 *
 */
void zb_kec_client_send_request_initiate_key_establishment(zb_uint8_t param)
{
  zb_uint8_t *is;
  zse_cert_nvram_t *existing_cert;

  {
    zb_uint8_t alarm_param;
    ZB_SCHEDULE_ALARM_CANCEL_AND_GET_BUF(zb_kec_client_send_request_initiate_key_establishment, ZB_ALARM_ANY_PARAM, &alarm_param);
    if (alarm_param != 0U)
    {
      zb_buf_free(alarm_param);
    }
  }

  if( ZSE_CTXC().ke.selected_ke_suite == 0U )
  {
    TRACE_MSG( TRACE_ZSE1,
               "> zb_kec_client_send_request_initiate_key_establishment:ERROR - selected key suite == 0", (FMT__0));
    zb_buf_free(param);
    return;
  }

  ZSE_CTXC().ke.ke_suite_num = zb_kec_get_suite_num(ZSE_CTXC().ke.selected_ke_suite);

  TRACE_MSG( TRACE_ZSE1,"> zb_kec_client_send_request_initiate_key_establishment: selected suite no %d (sizeof(b=%d))", (FMT__D_D, ZSE_CTXC().ke.ke_suite_num, sizeof(b)));

  existing_cert = zse_certdb_get_from_tc_storage(ZSE_CTXC().ke.ke_suite_num, NULL, &b);
  if(existing_cert == NULL)
  {
      TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd not found in certdb", (FMT__H, ZSE_CTXC().ke.ke_suite_num));
      zb_buf_free(param);
      return;
  }
  /*cstat !MISRAC2012-Rule-11.3 */
  /** @mdr{00002,94} */
  is = zb_kec_get_issuer(ZSE_CTXC().ke.ke_suite_num, (zb_kec_icu_t *)b.cert.u8);
  /*NOTE:can return ZB_BUSY*/
  if( RET_ERROR == zb_kec_load_keys( zb_kec_client_send_request_finish_initiate_key_establishment,
                                     param, ZSE_CTXC().ke.selected_ke_suite, b.ca.u8, b.cert.u8, b.pr.u8 ) )
  {
    ZVUNUSED(is);
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd issuer " TRACE_FORMAT_64 " found but it is broken", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( is )));
    zb_buf_free(param);
    return;
  }
}

static void zb_kec_client_retry_key_establishment_with_alarm(zb_uint8_t param)
{
  TRACE_MSG(TRACE_ZSE1, "zb_kec_client_retry_key_establishment_with_alarm param %hd", (FMT__H, param) );
  /* Received some response - cancel alarm for Initiate Key Establishment request */
  if (zb_buf_get_status(param) == RET_ERROR)
  {
    zb_uint8_t alarm_param;
    TRACE_MSG(TRACE_ZSE1, "ERROR sending initiate, retry", (FMT__0));
    ZB_SCHEDULE_ALARM_CANCEL_AND_GET_BUF(zb_kec_client_send_request_initiate_key_establishment, ZB_ALARM_ANY_PARAM, &alarm_param);
    if (alarm_param != 0U)
    {
      zb_buf_free(alarm_param);
    }
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_client_initiate_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
    if(!zb_kec_client_retry_key_establishment(param, 0))
    {
      TRACE_MSG(TRACE_ZSE1, "nothing to retry, stop CBKE", (FMT__0) );
      ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
      /* Inform upper layers about key establishment failed */
      kec_call_user_cb(param, (zb_uint16_t)RET_ERROR);
    }
  }
}

/**
 * The last step of sending initiate key establishment request
 * @param  param - buffer reference
 */
void zb_kec_client_send_request_finish_initiate_key_establishment(zb_uint8_t param)
{
  zb_uint8_t *is;

  //FIXME:DD:compute is again
  /*cstat !MISRAC2012-Rule-11.3 */
  /** @mdr{00002,95} */
  is = zb_kec_get_issuer(ZSE_CTXC().ke.ke_suite_num, (zb_kec_icu_t *)b.cert.u8);
  ZVUNUSED(is);

  if (RET_OK != zb_ecc_get_last_error())
  {
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd issuer " TRACE_FORMAT_64 " found but it is broken", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( is )));
    zb_buf_free(param);
    return;
  }

  TRACE_MSG( TRACE_ZSE1, "Certificate for suite(%hd) no %hd issuer " TRACE_FORMAT_64 " found", (FMT__H_H_A, ZSE_CTXC().ke.selected_ke_suite, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( is )));

/* Construct packet header */
  {
    zb_uint8_t i;
    zb_uint8_t *cmd_ptr = ZB_ZCL_START_PACKET_REQ(param)
    ZB_ZCL_CONSTRUCT_SPECIFIC_COMMAND_REQ_FRAME_CONTROL(cmd_ptr, ZB_ZCL_ENABLE_DEFAULT_RESPONSE)
    ZB_ZCL_CONSTRUCT_COMMAND_HEADER_REQ(cmd_ptr, ZB_ZCL_GET_SEQ_NUM(), ZB_SE_KEC_CMD_INITIATE_KE_REQUEST);
    ZB_ZCL_PACKET_PUT_DATA16_VAL(cmd_ptr, (ZSE_CTXC().ke.selected_ke_suite));
    ZB_ZCL_PACKET_PUT_DATA8(cmd_ptr, (ZSE_CTXC().ke.time_generate_eph));
    ZB_ZCL_PACKET_PUT_DATA8(cmd_ptr, (ZSE_CTXC().ke.time_confirm_key));
    for(i=0;i<(ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]);i++)
    {
      ZB_ZCL_PACKET_PUT_DATA8(cmd_ptr, *((zb_uint8_t *)(b.cert.u8)+i));
    }
    zb_se_kec_finish_packet_partner_cb(param, cmd_ptr, zb_kec_client_retry_key_establishment_with_alarm);
  }
/*Reset to initial ke stage*/
  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_INITIATE_REQUEST_SENT;

  ZB_SCHEDULE_ALARM(zb_kec_client_initiate_key_establishment_alarm, 0, ZB_KEC_RETRY_WAIT_TIME_DEFAULT);

}

void zb_kec_client_send_ephemeral_data_request_finish(zb_uint8_t param);


/**
 * Client send this cmd: Send Ephemeral Datal Request
 *
 * @param cb_done - callback that will be called after ephemeral data generation
 * @param param   - input buffer for generate and send the command
 */
static zb_ret_t zb_kec_client_send_ephemeral_data_request(zb_callback_t cb_done, zb_uint8_t param)
{
  zb_uint8_t random[ZB_MAX_RND_SIZE];
  zb_uint8_t j;

  if(ZSE_CTXC().ke.kec_cb != NULL)
  {
    TRACE_MSG(TRACE_ZSE1, "zb_kec_client_send_ephemeral_data_request callback busy, aborting...", (FMT__0));
    ZB_ASSERT(0);
    return RET_BUSY;
  }

  ZSE_CTXC().ke.kec_cb = cb_done;

  /**
  * C.3.1.2.3.2 Ephemeral Data Request Command
  * The Ephemeral Data Request command allows a device to communicate its ephemeral data
  * to another device and request that the device send back its own ephemeral data.
  */
  for(j = 0 ; j < ZB_RND_SIZE[ZSE_CTXC().ke.ke_suite_num] ; ++j)
  {
    random[j] = (zb_uint8_t)(ZB_RANDOM_U16() >> 4U) & 0xFFU;
  }
  zb_ecc_set_curve(ZSE_CTXC().ke.curve_id);
  zb_ecc_key_generation_async(zb_kec_client_send_ephemeral_data_request_finish,
                              param,
                              random,
                              ZSE_CTXC().ke.local_ephemeral_private_key.u8,
                              ZSE_CTXC().ke.local_ephemeral_public_key.u8);

  return RET_OK;
}


/**
 * The last step of ephemeral data generation
 * @param  param - parameter that will be passed to ZSE_CTXC().ke.kec_cb callback
 */
void zb_kec_client_send_ephemeral_data_request_finish(zb_uint8_t param)
{
  zb_uint32_t bytes_avail;
  zb_uint8_t i;
  zb_uint8_t *req_ptr;

#ifdef ZB_TH_ENABLED
  if (KEC_CLI_CH_DELAY_EPH_TIME>0) {
    TRACE_MSG( TRACE_ZSE1, "Client CH: delay ephemeral data request by %hd seconds", (FMT__H, KEC_CLI_CH_DELAY_EPH_TIME));
    ZB_SCHEDULE_ALARM(zb_kec_client_send_ephemeral_data_request_finish, param, (KEC_CLI_CH_DELAY_EPH_TIME * ZB_TIME_ONE_SECOND));
    KEC_CLI_CH_DELAY_EPH_TIME = 0;
    return;
  }
#endif /* ZB_TH_ENABLED */

  req_ptr = zb_se_kec_start_req(param, ZB_SE_KEC_CMD_EPHEMERAL_DATA_REQUEST, ZB_ZCL_ENABLE_DEFAULT_RESPONSE);

  TRACE_MSG( TRACE_ZSE1, "ephemeral keys generated", (FMT__0));
  DUMP_TRAF( "private:", ZSE_CTXC().ke.local_ephemeral_private_key.u8,ZB_PR_SIZE[ZSE_CTXC().ke.ke_suite_num],0);
  DUMP_TRAF( "public :", ZSE_CTXC().ke.local_ephemeral_public_key.u8,ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num],0);

  TRACE_MSG( TRACE_ZSE1, "> zb_kec_client_send_ephemeral_data_request", (FMT__0));

  /* Construct packet header */
  bytes_avail = ZB_ZCL_GET_BYTES_AVAILABLE(param, req_ptr,
                                           ZB_AF_SE_PROFILE_ID, ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT);
  TRACE_MSG(TRACE_ZSE3, "bytes_avail %hd, need: %hd", (FMT__H_H, bytes_avail, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]));

  if( bytes_avail >= ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num] )
  {
    for (i = 0; i < ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]; i++)
    {
      ZB_ZCL_PACKET_PUT_DATA8(req_ptr, ZSE_CTXC().ke.local_ephemeral_public_key.u8[i]); /*QEU - generate and send */
    }
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "ERROR, buffer is full", (FMT__0));
    ZB_ASSERT(0);
  }
  zb_se_kec_finish_packet( param, req_ptr, &ZSE_CTXC().ke.cmd_info );

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_EPHEMERAL_DATA_REQUEST_SENT;

  ZB_SCHEDULE_ALARM(zb_kec_client_initiate_key_establishment_alarm,
    0U, (zb_time_t)(ZSE_CTXC().ke.remote_ephemeral_timeout + 5UL) * ZB_TIME_ONE_SECOND);

  TRACE_MSG( TRACE_ZSE1, "< zb_kec_client_send_ephemeral_data_request", (FMT__0));

  if (ZSE_CTXC().ke.kec_cb != NULL)
  {
    ZB_SCHEDULE_CALLBACK(ZSE_CTXC().ke.kec_cb, param);  /*FIXME: what parameter do we need pass to callback?*/
    ZSE_CTXC().ke.kec_cb = NULL;
  }
}

void zb_kec_clnt_snd_cfrm_key_req_continue(zb_uint8_t param);

void zb_kec_clnt_snd_cfrm_key_req_finish(zb_uint8_t param);


/**
 * Client send this cmd: Send Confirm Key Request
 *
 * @param param - input buffer for generate and send the command
 */
static void zb_kec_client_send_confirm_key_request(zb_uint8_t param)
{
  zb_ret_t ret;

  /* C.3.1.2.3.3 Confirm Key Request Command
  The Confirm Key Request command allows the initiator sending device to confirm the key
  established with the responder receiving device based on performing a cryptographic hash
  using part of the generated keying material and the identities and ephemeral data of both parties.
  C.3.1.2.3.3.1 Payload Format
  The Confirm KeyRequest command payload shall be formatted as illustrated in Figure C-6.*/

  /*NOTE:follow function can return ZB_BUSY*/
  ret = zb_kec_generate_remote_public_key(zb_kec_clnt_snd_cfrm_key_req_continue, param);
  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_kec_generate_remote_public_key failed [%d]", (FMT__D, ret));
    ZB_ASSERT(0);
  }
}


/**
 * Intermediate step: Send Confirm Key Request
 * @param  param - input buffer for generate and send the command
 */
void zb_kec_clnt_snd_cfrm_key_req_continue(zb_uint8_t param)
{
  zb_ret_t ret;
  //FIXME: or need to interrupt function directly here and call
  //FIXME: zb_kec_common_send_terminate_key_establishment_cmd(buf, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, 0);
  if ( RET_ERROR == zb_ecc_get_last_error() )
  {
    /* NOTE: if cannot generate return with error no info in spec what to do in this case */
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  // if (RET_ERROR == zb_ecc_get_last_error())
  // {
  //   ZB_SCHEDULE_CALLBACK(zb_kec_clnt_snd_cfrm_key_req_finish, param);
  //   return;
  // }

  /* C.3.1.2.3.3 Confirm Key Request Command
  The Confirm Key Request command allows the initiator sending device to confirm the key
  established with the responder receiving device based on performing a cryptographic hash
  using part of the generated keying material and the identities and ephemeral data of both parties.
  C.3.1.2.3.3.1 Payload Format
  The Confirm KeyRequest command payload shall be formatted as illustrated in Figure C-6.*/

  /*NOTE:follow function can return ZB_BUSY*/
  ret = zb_kec_generate_shared_secret(zb_kec_clnt_snd_cfrm_key_req_finish, param);
  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_kec_generate_shared_secret failed [%d]", (FMT__D, ret));
    ZB_ASSERT(0);
  }
}


/**
 * Last step: Send Confirm Key Request
 * @param  param - input buffer for generate and send the command
 */
void zb_kec_clnt_snd_cfrm_key_req_finish(zb_uint8_t param)
{
  zb_uint32_t bytes_avail;
  zb_uint8_t macu[ZB_ECC_HASH_LEN];
  zb_uint8_t *remote_id = NULL;
  zb_ieee_addr_t ieee_addr;
  zb_uint8_t *req_ptr;

#ifdef ZB_TH_ENABLED
  if (KEC_CLI_CH_DELAY_CNF_TIME>0) {
    TRACE_MSG( TRACE_ZSE1, "Client CH: delay confirm key request by %hd seconds", (FMT__H, KEC_CLI_CH_DELAY_CNF_TIME));
    ZB_SCHEDULE_ALARM(zb_kec_clnt_snd_cfrm_key_req_finish, param, (KEC_CLI_CH_DELAY_CNF_TIME * ZB_TIME_ONE_SECOND));
    KEC_CLI_CH_DELAY_CNF_TIME = 0;
    return;
  }
#endif /* ZB_TH_ENABLED */

  if ( RET_ERROR == zb_ecc_get_last_error() )
  {
    /* NOTE: if cannot generate return with error no info in spec what to do in this case */
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_TRUE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  req_ptr = zb_se_kec_start_req(param, ZB_SE_KEC_CMD_CONFIRM_KEY_REQUEST, ZB_ZCL_ENABLE_DEFAULT_RESPONSE);

  TRACE_MSG( TRACE_ZSE1,"> zb_kec_client_send_confirm_key_request",(FMT__0) );

  bytes_avail = ZB_ZCL_GET_BYTES_AVAILABLE(param, req_ptr,
                                           ZB_AF_SE_PROFILE_ID, ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT);
  TRACE_MSG(TRACE_ZSE3, "bytes_avail %hd, need: %hd", (FMT__H_H, bytes_avail, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]));

  if( bytes_avail >= ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num] )
  {
    zb_uint8_t i;
    DUMP_TRAF("Shared_secret:", ZSE_CTXC().ke.Z.u8, ZB_SK_SIZE[ZSE_CTXC().ke.ke_suite_num], 0);
    zb_kec_generate_keyingdata(ZSE_CTXC().ke.Z.u8, ZSE_CTXC().ke.mac_key, ZSE_CTXC().ke.key_data);

    if( KEC_CS1 == ZSE_CTXC().ke.selected_ke_suite )
    {
      remote_id = ZSE_CTXC().ke.remote_certificate.cs1.subject;
    }
    if( KEC_CS2 == ZSE_CTXC().ke.selected_ke_suite )
    {
      remote_id = ZSE_CTXC().ke.remote_certificate.cs2.subject;
    }

    /* WARNING: IEEE has reverse byte order. */
    ZB_IEEE_ADDR_COPY(ieee_addr, ZB_PIBCACHE_EXTENDED_ADDRESS());
    inverse_bytes(ieee_addr, 8);

    zb_kec_generate_mac(ZSE_CTXC().ke.mac_key, 0x02, /* ZB_PIBCACHE_EXTENDED_ADDRESS() */ieee_addr, remote_id,
                        ZSE_CTXC().ke.local_ephemeral_public_key.u8, ZSE_CTXC().ke.remote_ephemeral_public_key.u8, macu);
    DUMP_TRAF("macu:", macu, 16, 0);

    for (i = 0; i < ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num]; i++)
    {
      ZB_ZCL_PACKET_PUT_DATA8(req_ptr, macu[i]);  // macu - generate and send
    }
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "ERROR, buffer is full", (FMT__0));
    ZB_ASSERT(0);
  }
  zb_se_kec_finish_packet( param, req_ptr, &ZSE_CTXC().ke.cmd_info );

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_CONFIRM_KEY_REQUEST_SENT;

  ZB_SCHEDULE_ALARM(zb_kec_client_initiate_key_establishment_alarm,
    0U, (zb_time_t)(ZSE_CTXC().ke.remote_confirm_timeout + 5UL) * ZB_TIME_ONE_SECOND);
}


static void zb_kec_client_handle_initiate_key_establishment_response_finish(zb_uint8_t param);


/**
 *
 * Client handler for Initiate Key Establishment response command
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_client_handle_initiate_key_establishment_response(zb_uint8_t param)
{
  zb_kec_init_ke_resp_cmd_t *ke_resp = (zb_kec_init_ke_resp_cmd_t *)zb_buf_begin(param);
  zb_zcl_attr_t* ke_suite_desc;
  zb_uint16_t ke_suite;
  zb_uint8_t *t_issuer;
  zse_cert_nvram_t *existing_cert;

  TRACE_MSG( TRACE_ZSE1,
             "> zb_kec_client_handle_initiate_key_establishment_response: param %hd",
             (FMT__H, param));

/**
 * C.3.1.3.3.1.2 Effect on Receipt
 * If the device is not currently in the middle of negotiating Key Establishment with the sending
 * device when it receives this message, it shall send back a Terminate Key Establishment
 * message with a result of BAD_MESSAGE. If the device is in the middle of Key Establishment
 * with the sender but did not receive this message in response to an Initiate Key Establishment
 * Request command, it shall send back a Terminate Key Establishment message with a result of
 * BAD_MESSAGE.
 */
  if(ZSE_CTXC().ke.ke_stage != KE_STAGE_CLIENT_INITIATE_REQUEST_SENT)
  {
    TRACE_MSG( TRACE_ZSE1, "Stage not suitable for initiate key establishment response command:kec: state %d",
               (FMT__D, ZSE_CTXC().ke.ke_stage));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return;
  }

  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Initiate KEC response packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return;
  }

  /* Received some response - cancel alarm for Initiate Key Establishment request */
  {
    zb_uint8_t alarm_param;
    ZB_SCHEDULE_ALARM_CANCEL_AND_GET_BUF(zb_kec_client_send_request_initiate_key_establishment, ZB_ALARM_ANY_PARAM, &alarm_param);
    if (alarm_param != 0U)
    {
      zb_buf_free(alarm_param);
    }
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_client_initiate_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }

/* Check for only 1 bit set in the suite requested */
  if( zb_bit_cnt16(ke_resp->ke_suite) != 1U )
  {
    TRACE_MSG( TRACE_ZSE1, "Requested suite not 1 bit set check:kec: requested suite %d",
               (FMT__D, ke_resp->ke_suite));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }
/* Check suite supported */
  TRACE_MSG( TRACE_ZSE1, "Check supported suite:kec: requested suite %d, supported suite %d",
  (FMT__D_D, ke_resp->ke_suite, ZSE_CTXC().ke.selected_ke_suite));

  ke_suite_desc = zb_zcl_get_attr_desc_a(
    ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).dst_endpoint,
    ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
    ZB_ZCL_CLUSTER_CLIENT_ROLE,
    ZB_ZCL_ATTR_KEY_ESTABLISHMENT_SUITE_ID);

  ZB_ASSERT(ke_suite_desc != NULL);

  ke_suite = *(zb_uint16_t*)ke_suite_desc->data_p;

  if( (ke_resp->ke_suite & ke_suite) == 0U )
  {
    TRACE_MSG(TRACE_ZSE1, "UNSUPPORTED suite",(FMT__0) );
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNSUPPORTED_SUITE, 0);
    return;
  }
  else
  {
    TRACE_MSG(TRACE_ZSE1, "Supported suite",(FMT__0) );
  }
/*For all future server messages within the current key establishment negotiation, the Key
Establishment suite value received in this message shall be utilized.*/
  ZSE_CTXC().ke.selected_ke_suite = ke_resp->ke_suite;

  if((zb_uint8_t)zb_buf_len(param)<(ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]+4u))
  {
    TRACE_MSG( TRACE_ZSE1, "Invalid len of incoming message: recv=%hd!<%hd", (FMT__H, zb_buf_len(param),ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]+4));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  TRACE_MSG( TRACE_ZSE1, "Ephemeral data generate time %d", (FMT__D, ke_resp->eph_data_gen_time));
  TRACE_MSG( TRACE_ZSE1, "Confirm Key generate time %d", (FMT__D, ke_resp->conf_key_gen_time));

  if((ke_resp->eph_data_gen_time>254U) || (ke_resp->conf_key_gen_time>254U))
  {
    TRACE_MSG( TRACE_ZSE1, "Unsupported gen_time out of boundaries:kec:", (FMT__0));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_BAD_MESSAGE_WAIT);
    return;
  }

  ZSE_CTXC().ke.remote_ephemeral_timeout = ke_resp->eph_data_gen_time;
  ZSE_CTXC().ke.remote_confirm_timeout = ke_resp->conf_key_gen_time;

/* Check resources
  FIXME:AEV - single threaded yet, maybe check resources later */

/* Check certificate */
  //FIXME: DD need to discuss. Move remote_id receiving to finish function
  switch(ke_resp->ke_suite)
  {
    case KEC_CS1:
      /*remote_id = (zb_uint8_t *)&ke_resp->icu.cs1.subject;*/
      break;
    case KEC_CS2:
      /*
      If the implicit certificate received in the message is for the Crypto Suite 2 Cipher Suite, then
      the receiving device shall check the status of the KeyUsage field and, if the Key Agreement
      flag is NOT set, shall send a Terminate Key Establishment message with the status of INVALID_CERTIFICATE.

       C.3.1.2.3.1.2  Effect on Receipt
      The receiving device shall also check the Type, Curve and Hash fields of
      such a certificate, and send a Terminate Key Establishment message with the status of
      INVALID_CERTIFICATE if any of these fields contains an invalid value.*/
      if( (!IS_KEC_KEY_AGREEMENT_FLAG(ke_resp->icu.cs2.key_usage))
           || (ke_resp->icu.cs2.type !=0x00U)
           || (ke_resp->icu.cs2.curve !=0x0DU)
           || (ke_resp->icu.cs2.hash !=0x08U))
      {
        ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
        zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE, 0);
        return;
      }
      /*remote_id = (zb_uint8_t *)&ke_resp->icu.cs2.subject;*/
      break;
    default:
      TRACE_MSG( TRACE_ZSE1, "Failed checking implicit certificate:kec:unknown suite", (FMT__0));
      ZB_ASSERT(0);
      break;
  }

/**
 * Check Issuer - scan database of certificates, exit if not found, set time
 * NOTE: Maybe Check only issuer??? Why do we must scan certificates database.
 * Is this error or not in spec? Need to check this.
 * C.3.1.3.3.1.2 Effect on Receipt
 * On receipt of this command the device shall check the Issuer field of the device\'s implicit
 * certificate. If the Issuer field does not contain a value that corresponds to a known Certificate
 * Authority, the device shall send a Terminate Key Establishment command with the status
 * value set to UNKNOWN_ISSUER.
 */
  if(ke_resp->ke_suite == KEC_CS1 )
  {
    t_issuer = (zb_uint8_t *)&ke_resp->icu.cs1.issuer;
  }
  else if(ke_resp->ke_suite == KEC_CS2 )
  {
    t_issuer = (zb_uint8_t *)&ke_resp->icu.cs2.issuer;
  }
  else{
    t_issuer = NULL;
  }

  DUMP_TRAF( "Issuer field:", t_issuer, 8, 0);

  TRACE_MSG( TRACE_ZSE1, "Issuer of incoming cert: " TRACE_FORMAT_64, (FMT__A, TRACE_ARG_64(t_issuer)));
  //FIXME:DD - what will we need to do if t_issuer verification is failed?

  ZB_ASSERT(t_issuer);

  existing_cert = zse_certdb_get_from_tc_storage(ZSE_CTXC().ke.ke_suite_num, t_issuer, &b);
  if(existing_cert == NULL)
  {
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd issuer " TRACE_FORMAT_64 " not found in certdb", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( t_issuer )));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNKNOWN_ISSUER, 0);
    return;
  }
  if( RET_OK != zb_kec_load_keys( zb_kec_client_handle_initiate_key_establishment_response_finish,
                                  param, ke_resp->ke_suite, b.ca.u8, b.cert.u8, b.pr.u8 ) )
  {
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd issuer " TRACE_FORMAT_64 " found but it is broken", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( t_issuer )));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE, 0);
    return;
  }

  //FIXME: This call will be triggered if previous if-statement do not trigger
  // zb_kec_client_handle_initiate_key_establishment_response_finish(RET_OK);
}


/**
 *
 * The last step for client handler for Initiate Key Establishment response command
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_client_handle_initiate_key_establishment_response_finish(zb_uint8_t param)
{
  zb_ret_t ret;
  zb_kec_init_ke_resp_cmd_t *ke_resp = (zb_kec_init_ke_resp_cmd_t *)zb_buf_begin(param);
  zb_ieee_addr_t remote_addr;
  zb_uint8_t *remote_id;
  zb_uint8_t *t_issuer;

  TRACE_MSG( TRACE_ZSE1, ">zb_kec_client_handle_initiate_key_establishment_response_finish", (FMT__0));

  //FIXME:DD: get t_issuer again
  t_issuer = (KEC_CS1 == ke_resp->ke_suite) ? (zb_uint8_t *)&ke_resp->icu.cs1.issuer : (zb_uint8_t *)&ke_resp->icu.cs2.issuer;
  ZVUNUSED(t_issuer);

  if( RET_OK != zb_ecc_get_last_error() )
  {
    TRACE_MSG( TRACE_ZSE1, "Certificate for suite no %hd issuer " TRACE_FORMAT_64 " found but it is broken", (FMT__H_A, ZSE_CTXC().ke.ke_suite_num, TRACE_ARG_64( t_issuer )));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE, 0);
    return;
  }

  /* If the device accepts the response it shall send an Ephemeral Data Request command. The device
  should verify the certificate belongs to the address that the device is communicating with. The
  binding between the identity of the communicating device and its address is verifiable using out-
  of-band method.*/
  if (zb_address_ieee_by_short(ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr, remote_addr) == RET_OK)
  {
    inverse_bytes(remote_addr, 8);
  }

  remote_id = (KEC_CS1 == ke_resp->ke_suite) ? (zb_uint8_t *)&ke_resp->icu.cs1.subject : (zb_uint8_t *)&ke_resp->icu.cs2.subject;

  if ((( ZB_MEMCMP(remote_addr, remote_id, 8) == 0 )))
  {
      //DUMP_TRAF( "Remote ieee addr:", remote_addr,8,0);
  }
  else
  {
    DUMP_TRAF( "Remote ieee addr:", remote_addr, 8, 0);
    DUMP_TRAF( "Remote id:", remote_id, 8, 0);
    TRACE_MSG( TRACE_ZSE1, "kec:certificate and device address mismatch: cert:0x%08x src:0x%08x", (FMT__D_D, remote_id, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, 0);
    return;
  }

  ZB_MEMCPY(&ZSE_CTXC().ke.remote_certificate, &ke_resp->icu, ZB_CERT_SIZE[ZSE_CTXC().ke.ke_suite_num]);

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_INITIATE_RESPONSE_RECEIVED;

  ret = zb_kec_client_send_ephemeral_data_request(NULL, param); //FIXME:DD, we do not pass any callback so far. Also this function can return ZB_BUSY
  if (ret != RET_OK)
  {
    TRACE_MSG(TRACE_ERROR, "zb_kec_client_send_ephemeral_data_request failed [%d]", (FMT__D, ret));
    ZB_ASSERT(0);
  }

  TRACE_MSG( TRACE_ZSE1, "<zb_kec_client_handle_initiate_key_establishment_response_finish", (FMT__0));
}


/**
 *
 * Client handler for Ephemeral Data response command
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_client_handle_ephemeral_data_response(zb_uint8_t param)
{
  zb_kec_eph_data_resp_cmd_t *ephemeral_data_qev = (zb_kec_eph_data_resp_cmd_t *)zb_buf_begin(param);

/**
 * C.3.1.3.3.1.2  Effect on Receipt
 * If  the  device  is  not  currently in  the  middle  of  negotiating  Key  Establishment  with  the  sending
 * device  when  it  receives  this  message,  it  shall  send  back  a  Terminate  Key  Establishment
 * message  with  a  result  of  BAD_MESSAGE.  If  the  device  is  in  the  middle  of  Key  Establishment
 * with  the  sender  but  did  not  receive  this  message  in  response  to  an  Initiate  Key  Establishment
 * Request  command,  it  shall  send  back  a  Terminate  Key  Establishment  message  with  a  result  of
 * BAD_MESSAGE.
 */
  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Ephemeral packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return;
  }

  if(ZSE_CTXC().ke.ke_stage != KE_STAGE_CLIENT_EPHEMERAL_DATA_REQUEST_SENT)
  {
    TRACE_MSG( TRACE_ZSE1, "Stage not suitable for ephemeral_data response command:kec: state %d",
         (FMT__D, ZSE_CTXC().ke.ke_stage));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, ZB_KEC_NO_RESOURCES_WAIT);
    return;
  }

  if(zb_buf_len(param) < ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num])
  {
    TRACE_MSG( TRACE_ZSE1, "Invalid len of incoming message: recv=%hd!<%hd", (FMT__H, zb_buf_len(param),ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]));
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE, 0);
    return;
  }

  ZB_MEMCPY((zb_uint8_t *)(&ZSE_CTXC().ke.remote_ephemeral_public_key), ephemeral_data_qev, ZB_QE_SIZE[ZSE_CTXC().ke.ke_suite_num]);

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_EPHEMERAL_DATA_RESPONSE_RECEIVED;
/**
 * If the device accepts the response it shall send an Ephemeral Data Request command. The device
 * should verify the certificate belongs to the address that the device is communicating with. The
 * binding between the identity of the communicating device and its address is verifiable using out-
 * of-band method.
 */
/* Received response - cancel alarm for waiting ephemeral response */
  ZB_SCHEDULE_ALARM_CANCEL(zb_kec_client_initiate_key_establishment_alarm, ZB_ALARM_ANY_PARAM);

  zb_kec_client_send_confirm_key_request(param);
}

void zb_kec_client_retry_key_establishment_delayed(zb_uint8_t param);

/**
 *
 * Client handler for Confirm Key response command
 *
 * @param buf - input buffer for generate and send the command
 * @return - confirm success or failure
 */
static zb_bool_t zb_kec_client_handle_confirm_key_response(zb_uint8_t param)
{
  zb_uint8_t macx[ZB_ECC_HASH_LEN];
  zb_uint8_t *remote_id = NULL;
  zb_ieee_addr_t ieee_addr;

  zb_uint8_t *macv = zb_buf_begin(param);

/**
 * C.3.1.3.3.3.2 Effect on Receipt
 * If the device is not currently in the middle of negotiating Key Establishment with the sending
 * device when it receives this message, it shall send back a Terminate Key Establishment
 * message with a result of BAD_MESSAGE. If the device is in the middle of Key Establishment
 * with the sender but did not receive this message in response to an Confirm Key Request
 * command, it shall send back a Terminate Key Establishment message with a result of
 * BAD_MESSAGE.
 */
  if( ZSE_CTXC().ke.ke_stage != KE_STAGE_CLIENT_CONFIRM_KEY_REQUEST_SENT )
  {
    TRACE_MSG( TRACE_ZSE1, "Stage not suitable for confirm key response command:kec: state %d",
               (FMT__D, ZSE_CTXC().ke.ke_stage));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return ZB_FALSE;
  }

  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Confirm key response packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return ZB_FALSE;
  }

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_CONFIRM_KEY_RESPONSE_RECEIVED;

  if( KEC_CS1 == ZSE_CTXC().ke.selected_ke_suite )
  {
    remote_id = ZSE_CTXC().ke.remote_certificate.cs1.subject;
  }
  if( KEC_CS2 == ZSE_CTXC().ke.selected_ke_suite )
  {
    remote_id = ZSE_CTXC().ke.remote_certificate.cs2.subject;
  }

/**
 * On receipt of the Confirm Key Response command the initiator device shall compare the
 * received MACV value with its own reconstructed version of the MACV. If the two match
 * then the initiator can consider the key establishment process to be successful. If the two do
 * not match, the initiator should send a Terminate Key Establishment command with a result of BAD_KEY_CONFIRM.
 */

  /* WARNING: IEEE has reverse byte order. */
  ZB_IEEE_ADDR_COPY(ieee_addr, ZB_PIBCACHE_EXTENDED_ADDRESS());
  inverse_bytes(ieee_addr, 8);

  zb_kec_generate_mac(ZSE_CTXC().ke.mac_key, 0x03, remote_id, /* ZB_PIBCACHE_EXTENDED_ADDRESS() */ieee_addr,
                      ZSE_CTXC().ke.remote_ephemeral_public_key.u8, ZSE_CTXC().ke.local_ephemeral_public_key.u8, macx);
  DUMP_TRAF( "macx:", macx,16,0);
  DUMP_TRAF( "macv:", macv,16,0);

  if(ZB_MEMCMP(macx, macv, ZB_MAC_SIZE[ZSE_CTXC().ke.ke_suite_num]) != 0)
  {
    zb_ret_t ret;

    TRACE_MSG( TRACE_ZSE1, "macv not equal to macx calculated locally, terminate KE", (FMT__0));
    zb_kec_common_send_terminate_key_establishment_cmd_to_partner(param, ZB_FALSE, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM, 0);
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    ret = zb_buf_get_out_delayed(zb_kec_client_retry_key_establishment_delayed);
    if (ret != RET_OK)
    {
      TRACE_MSG(TRACE_ERROR, "Failed zb_buf_get_out_delayed [%d]", (FMT__D, ret));
    }
    return ZB_FALSE;
  }
  /* if success */
  {
    remote_id = NULL;

    if( ZSE_CTXC().ke.selected_ke_suite == KEC_CS1 )
    {
      remote_id = (zb_uint8_t *)&ZSE_CTXC().ke.remote_certificate.cs1.subject;
    }

    if( ZSE_CTXC().ke.selected_ke_suite == KEC_CS2 )
    {
      remote_id = (zb_uint8_t *)&ZSE_CTXC().ke.remote_certificate.cs2.subject;
    }

    /* WARNING: IEEE has reverse byte order. */
    ZB_IEEE_ADDR_COPY(ieee_addr, remote_id);
    inverse_bytes(ieee_addr, 8);

    TRACE_MSG( TRACE_ERROR, "KEC: Update key for " TRACE_FORMAT_64, (FMT__A, TRACE_ARG_64( ieee_addr )));
    TRACE_MSG( TRACE_ERROR, "Client side of CBKE - APS key: " TRACE_FORMAT_128, (FMT__B, TRACE_ARG_128(ZSE_CTXC().ke.key_data)));

    (void)zb_secur_update_key_pair(ieee_addr, (zb_uint8_t*) ZSE_CTXC().ke.key_data, ZB_SECUR_UNIQUE_KEY, ZB_SECUR_VERIFIED_KEY, ZB_SECUR_KEY_SRC_CBKE);
#if defined TC_SWAPOUT && defined ZB_COORDINATOR_ROLE
    if (ZB_IS_TC())
    {
      /* Indicate to the app that new verified key is create - time to bakup */
      zb_tcsw_key_added();
    }
#endif
  }

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_FINISHED;

  {
    zb_uint8_t alarm_param;
    ZB_SCHEDULE_ALARM_CANCEL_AND_GET_BUF(zb_kec_client_send_request_initiate_key_establishment, ZB_ALARM_ANY_PARAM, &alarm_param);
    if (alarm_param != 0U)
    {
      zb_buf_free(alarm_param);
    }
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_client_initiate_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }

  (void)zb_zcl_send_default_handler(param, &ZSE_CTXC().ke.cmd_info, ZB_ZCL_STATUS_SUCCESS);

  /* Inform upper layers about key establishment done ok */
  kec_call_user_cb(0, RET_OK);

  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
  /* No zb_buf_free() - buf is used for ZCL default response! */
  return ZB_TRUE;
}

void zb_kec_client_retry_key_establishment_delayed(zb_uint8_t param)
{
  TRACE_MSG(TRACE_ZSE1, "zb_kec_client_retry_key_establishment_delayed param %hd", (FMT__H, param) );
  if(!zb_kec_client_retry_key_establishment(param, 0))
  {
    TRACE_MSG(TRACE_ZSE1, "nothing to retry, stop CBKE", (FMT__0) );
    ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
    /* Inform upper layers about key establishment failed */
    kec_call_user_cb(param, (zb_uint16_t)RET_ERROR);
  }
}

static void zb_kec_client_initiate_key_establishment_alarm(zb_uint8_t param)
{
  ZVUNUSED(param);
  /* Alarm already timed out, so retry key establishment immediately */
  TRACE_MSG(TRACE_ZSE1, "zb_kec_client_initiate_key_establishment_alarm", (FMT__0) );
  TRACE_MSG(TRACE_ZSE1, "Stage: %hd", (FMT__D, ZSE_CTXC().ke.ke_stage));
  switch (ZSE_CTXC().ke.ke_stage)
  {
    case KE_STAGE_CLIENT_START:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_START", (FMT__0));
      break;
    case KE_STAGE_CLIENT_INITIATE_REQUEST_SENT:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_INITIATE_REQUEST_SENT", (FMT__0));
      /* Request sent but no reply, we will retry it. */
      if (zb_buf_get_out_delayed(zb_kec_client_retry_key_establishment_delayed) != RET_OK)
      {
        TRACE_MSG(TRACE_ERROR, "Failed zb_buf_get_out_delayed!", (FMT__0));
      }
      break;
    case KE_STAGE_CLIENT_INITIATE_RESPONSE_RECEIVED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_INITIATE_RESPONSE_RECEIVED", (FMT__0));
      break;
    case KE_STAGE_CLIENT_EPHEMERAL_DATA_REQUEST_SENT:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_EPHEMERAL_DATA_REQUEST_SENT", (FMT__0));
      /* C.3.1.3.3.2.2 Effect on Receipt
        If the device is in the middle of Key Establishment with the sender but did not receive
        this message in response to an Ephemeral Data Request Command, it shall send back a Terminate
        Key Establishment message with a result of BAD_MESSAGE. 4238*/
      ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
      /* zb_buf_get_out_delayed(zb_kec_terminate_partner_bad_message); due to test spec 15.25 step 6 Validation */
      break;
    case KE_STAGE_CLIENT_EPHEMERAL_DATA_RESPONSE_RECEIVED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_EPHEMERAL_DATA_RESPONSE_RECEIVED", (FMT__0));
      break;
    case KE_STAGE_CLIENT_CONFIRM_KEY_REQUEST_SENT:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_CONFIRM_KEY_REQUEST_SENT", (FMT__0));
      /* C.3.1.3.3.3.2 Effect on Receipt
        If the device is in the middle of Key Establishment with the sender but did not receive
        this message in response to an Confirm Key Request Command, it shall send back a Terminate
        Key Establishment message with a result of BAD_MESSAGE. 4263*/
      ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
      /* zb_buf_get_out_delayed(zb_kec_terminate_partner_bad_message); */
      break;
    case KE_STAGE_CLIENT_CONFIRM_KEY_RESPONSE_RECEIVED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_CONFIRM_KEY_RESPONSE_RECEIVED", (FMT__0));
      break;
    case KE_STAGE_CLIENT_FINISHED:
      TRACE_MSG(TRACE_ZSE1, "KE_STAGE_CLIENT_FINISHED", (FMT__0));
      break;
    default:
      TRACE_MSG(TRACE_ZSE1, "unknown state", (FMT__0));
      break;
  }
}

static zb_bool_t zb_kec_client_retry_key_establishment(zb_uint8_t param, zb_time_t wait_time)
{
  zb_uint8_t cs = zb_kec_get_suite_num(ZSE_CTXC().ke.selected_ke_suite) + 1U;
  zb_uint16_t cs_aux;
  zb_bool_t cs_found = ZB_FALSE;
  zb_zcl_attr_t* ke_suite_desc;
  zb_uint16_t* ke_suite;
  zse_cert_nvram_t *existing_cert;

  ke_suite_desc = zb_zcl_get_attr_desc_a(ZSE_CTXC().ke.src_ep,
                                         ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
                                         ZB_ZCL_CLUSTER_CLIENT_ROLE,
                                         ZB_ZCL_ATTR_KEY_ESTABLISHMENT_SUITE_ID);

  ZB_ASSERT(ke_suite_desc != NULL);

  ke_suite = (zb_uint16_t*)ke_suite_desc->data_p;

  TRACE_MSG( TRACE_ZSE1, "supported KE Suite %d", (FMT__D, *ke_suite));

 /* It is not possible to use 'for' loop due to MISRA rule 14.2.
  * Variable 'cs' is modified in a loop body => it can not be used as a loop counter. */
  if (ZB_KEC_VALID_SUITE_NUMBER(cs-1U))
  {
    while (cs > 0U)
    {
      TRACE_MSG(TRACE_ZSE1, "cs %hd", (FMT__H, cs));

      cs_aux = (zb_uint16_t)(1UL<<(cs-1U));
      if(((*ke_suite) & cs_aux)>0U)
      {
        existing_cert = zse_certdb_get_from_tc_storage(cs-1U, NULL, &b);
        if(existing_cert!=NULL)
        {
          TRACE_MSG( TRACE_ZSE1, "Certificate for CryptoSuite%hd found in certdb", (FMT__H, cs));
          ZSE_CTXC().ke.ke_suite_num = zb_kec_get_suite_num((zb_uint16_t)1U<<(cs-1U));
          ZSE_CTXC().ke.selected_ke_suite = (zb_uint16_t)1U<<(cs-1U);
          ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
          cs_found = ZB_TRUE;
          break;
        }
      }
      cs--;
    }
  }
  if(cs_found==ZB_TRUE)
  {
    TRACE_MSG( TRACE_ERROR, "CBKE retry with CryptoSuite%hd", (FMT__H, cs));
    ZB_SCHEDULE_ALARM(zb_kec_client_send_request_initiate_key_establishment, param, wait_time * ZB_TIME_ONE_SECOND);
  }
  else
  {
    TRACE_MSG( TRACE_ERROR, "CBKE: we have tried all available CryptoSuites, exiting", (FMT__0));
  }
  return cs_found;
}

/**
 *
 * Client handler for Terminate Key Establishment command
 *
 * @param param - input buffer for generate and send the command
 *
 */
static void zb_kec_client_handle_terminate_key_establishment_cmd(zb_uint8_t param)
{
  zb_kec_term_cmd_t *term_info = (zb_kec_term_cmd_t *)zb_buf_begin(param);

  TRACE_MSG( TRACE_ZSE1, "zb_kec_client_handle_terminate_key_establishment_cmd:kec: status %hd wait_time %hd, key_suite %hd",
             (FMT__H_H_H, term_info->status_code,term_info->wait_time,term_info->key_suite));


  if(ZSE_CTXC().ke.dst_addr.addr_short != ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr)
  {
    TRACE_MSG( TRACE_ZSE1, "Terminate packet from alien device:kec: device 0x%04x", (FMT__D, ZB_ZCL_PARSED_HDR_SHORT_DATA(&ZSE_CTXC().ke.cmd_info).source.u.short_addr));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return;
  }

  /* Received terminate - cancel alarm for Initiate Key Establishment request */
  {
    zb_uint8_t alarm_param;
    ZB_SCHEDULE_ALARM_CANCEL_AND_GET_BUF(zb_kec_client_send_request_initiate_key_establishment, ZB_ALARM_ANY_PARAM, &alarm_param);
    if (alarm_param != 0U)
    {
      zb_buf_free(alarm_param);
    }
    ZB_SCHEDULE_ALARM_CANCEL(zb_kec_client_initiate_key_establishment_alarm, ZB_ALARM_ANY_PARAM);
  }

  /* pass to user more parameters */
  ZSE_CTXC().commissioning.ke_term_info = *term_info;
  switch ( term_info->status_code )
  /*cstat -MISRAC2012-Rule-16.* */
  /* Rule-16.* The keyword return has an equivalent behaviour as the break */
  {
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_MESSAGE:
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES:
    /*cstat +MISRAC2012-Rule-16.* */
/*  C.3.1.3.3.4.2  Effect on Receipt
    On receipt of the Terminate Key Establishment command the device shall terminate key
    establishment with the sender. If the device receives a status of BAD_MESSAGE or
    NO_RESOURCES it shall wait at least the time specified in the Wait Time field before trying to
    re-initiate Key Establishment with the device.
FIXME:AEV:TODO:Wait and retry schedule*/
      ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;
      ZB_SCHEDULE_ALARM(zb_kec_client_send_request_initiate_key_establishment, param, term_info->wait_time*ZB_TIME_ONE_SECOND);
      return;
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNSUPPORTED_SUITE:
    /*FIXME:AEV:The next three errors must not retry by spec. but we can make retry on another CryptoSuite*/
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNKNOWN_ISSUER:
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM:
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE:
/*  If the device receives a status of UNSUPPORTED_SUITE it should examine the
    KeyEstablishmentSuite field to determine if another suite can be used that is supported by
    the partner device. It may re-initiate key establishment using that one of the supported suites
    after waiting the amount of time specified in the Wait Time field. If the device does not
    support any of the types in the KeyEstablishmentSuite field, it should not attempt key
    establishment again with that device.
FIXME:AEV:TODO:if initiator - reinitiate with another suite*/
      if (zb_kec_client_retry_key_establishment(param, term_info->wait_time*ZB_TIME_ONE_SECOND))
      {
        TRACE_MSG( TRACE_ZSE1, "CBKE restarted", (FMT__0));
        return;
      }
      else
      {
        TRACE_MSG( TRACE_ZSE1, "CBKE stopped, call user_cb", (FMT__0));
      }
      break;
    /*case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_BAD_KEY_CONFIRM:
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_UNKNOWN_ISSUER:*/
/*  If the device receives a status of UNKNOWN_ISSUER or BAD_KEY_CONFIRM the device should not attempt
    key establishment again with the device, as it is unlikely that another attempt will be successful.
    */
/*    break;
    case ZB_SE_KEY_ESTABLISHMENT_TERMINATE_INVALID_CERTIFICATE:

    break;*/
    default:
      TRACE_MSG( TRACE_ZSE1, "zb_kec_terminate_key_establishment_req:unknown status:kec: status %h",
              (FMT__H, term_info->status_code));
      break;
  }
//FIXME:AEV:TODO: on exit stage must be reset
  ZSE_CTXC().ke.ke_stage = KE_STAGE_CLIENT_START;

  kec_call_user_cb(param, term_info->status_code);
}


/**
 *
 * Client commands handler/processor
 *
 * @param param - buffer reference with input command
 *
 */
static zb_bool_t zb_zcl_process_kec_client_specific_commands(zb_uint8_t param)
{
  zb_bool_t processed = ZB_TRUE;
  zb_bool_t result = ZB_TRUE;

  ZB_ZCL_COPY_PARSED_HEADER(param, &ZSE_CTXC().ke.cmd_info);

  TRACE_MSG( TRACE_ZSE1,
             "> zb_zcl_process_kec_client_specific_commands: param %hd",
             (FMT__H, param));

  TRACE_MSG( TRACE_ZSE1, "Current KE Stage %d", (FMT__D, ZSE_CTXC().ke.ke_stage));

  if (ZSE_CTXC().ke.ke_status != 0U) /* server exchange active */
  {
    TRACE_MSG(TRACE_ZSE3, "Server active, drop client command and send no_resources to alien", (FMT__0));
    zb_kec_common_send_terminate_key_establishment_cmd_to_alien(param, ZB_SE_KEY_ESTABLISHMENT_TERMINATE_NO_RESOURCES, ZB_KEC_NO_RESOURCES_WAIT);
    return ZB_TRUE;
  }

  switch (ZSE_CTXC().ke.cmd_info.cmd_id)
  {
    case ZB_SE_KEC_CMD_INITIATE_KE_RESPONSE:
      zb_kec_client_handle_initiate_key_establishment_response(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_INITIATE_KE_RESPONSE command", (FMT__0));

      break;
    case ZB_SE_KEC_CMD_EPHEMERAL_DATA_RESPONSE:
      zb_kec_client_handle_ephemeral_data_response(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_EPHEMERAL_DATA_RESPONSE command", (FMT__0));

      break;
    case ZB_SE_KEC_CMD_CONFIRM_KEY_RESPONSE:
      result = zb_kec_client_handle_confirm_key_response(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_CONFIRM_KEY_RESPONSE command", (FMT__0));

      break;
    case ZB_SE_KEC_CMD_TERMINATE_KE_SERVER:
      zb_kec_client_handle_terminate_key_establishment_cmd(param);
      TRACE_MSG(TRACE_ZSE3, "Processed ZB_SE_KEC_CMD_TERMINATE_KE_SERVER command", (FMT__0));

      break;
    default:
      processed = ZB_FALSE;
      result = ZB_FALSE;
      break;
  }
  if(!processed)
  {
    (void)zb_zcl_send_default_handler(param, &ZSE_CTXC().ke.cmd_info,
      result == ZB_TRUE ? ZB_ZCL_STATUS_SUCCESS : ZB_ZCL_STATUS_FAIL);
    processed = ZB_TRUE;
  }

  TRACE_MSG(TRACE_ZSE1,
            "< zb_zcl_process_kec_client_specific_commands: processed %d result %d",
            (FMT__D, processed, result));

  return processed;
}


/**
 *
 * Client command to initiate key Establishment
 *
 * @param param - buffer reference for command send
 * @param src_ep - source endpoint to send command from
 * @param dst_ep - destination endpoint to send command to
 * @param dst_addr_short - destination address to send command to
 * @param cb - callback function to call after key establishment completion
 *
 */
zb_ret_t zb_se_kec_initiate_key_establishment( zb_uint8_t param,
                                               zb_uint8_t src_ep,
                                               zb_uint8_t dst_ep,
                                               zb_uint16_t dst_addr_short,
                                               zb_callback_t cb )
{
  zb_uint8_t cs;
  zb_uint16_t cs_aux;
  zse_cert_nvram_t *existing_cert;
  zb_zcl_attr_t* ke_suite_desc;
  zb_uint16_t* ke_suite;

  ke_suite_desc = zb_zcl_get_attr_desc_a(src_ep,
                                         ZB_ZCL_CLUSTER_ID_KEY_ESTABLISHMENT,
                                         ZB_ZCL_CLUSTER_CLIENT_ROLE,
                                         ZB_ZCL_ATTR_KEY_ESTABLISHMENT_SUITE_ID);

  ZB_ASSERT(ke_suite_desc != NULL);

  ke_suite = (zb_uint16_t*)ke_suite_desc->data_p;

  TRACE_MSG( TRACE_ZSE1, "supported KE Suite %d", (FMT__D, *ke_suite));
  //NOTE: detect cs from loaded certs;
  ZSE_CTXC().ke.src_ep = src_ep;
  ZSE_CTXC().ke.dst_ep = dst_ep;
  ZSE_CTXC().ke.dst_addr.addr_short = dst_addr_short;
  ZSE_CTXC().ke.ke_suite_num = zb_kec_get_suite_num(0);
  ZSE_CTXC().ke.selected_ke_suite = 0;
  cs = 16;

  /* It is not possible to use 'for' loop due to MISRA rule 14.2.
   * Variable 'cs' is modified in a loop body => it can not be used as a loop counter. */
  while (cs > 0U)
  {
    cs_aux = (zb_uint16_t)(1UL<<(cs-1U));
    if(((*ke_suite) & cs_aux)>0U)
    {
      existing_cert = zse_certdb_get_from_tc_storage((cs-1U), NULL, &b);
      if(existing_cert!=NULL)
      {
        TRACE_MSG( TRACE_ZSE1, "Certificate for CryptoSuite%hd found in certdb", (FMT__H, cs));
        ZSE_CTXC().ke.ke_suite_num = zb_kec_get_suite_num((zb_uint16_t)(1UL<<(cs-1U)));
        ZSE_CTXC().ke.selected_ke_suite = (zb_uint16_t)(1UL<<(cs-1U));
        break;
      }
    }
    cs--;
  }

  TRACE_MSG(TRACE_ZSE1, "KEC:zb_se_kec_initiate_key_establishment: src_ep %hd dst_ep %hd CryptoSuite%hd", (FMT__H_H, src_ep, dst_ep, cs));
  if( cb != NULL )
  {
    ZSE_CTXC().ke.user_cb = cb;
    TRACE_MSG(TRACE_ZSE1, "KEC:user callback added: %p", (FMT__P, cb));
  }

  ZB_SCHEDULE_CALLBACK(zb_kec_client_send_request_initiate_key_establishment, param);
  return RET_OK;
}

#endif /* ZB_SE_ENABLE_KEC_CLIENT */


/**
 *
 * Common commands processor for Server and Client
 *
 * @param param - buffer reference with input command
 *
 */
zb_bool_t zb_zcl_process_kec_specific_commands(zb_uint8_t param)
{
  zb_zcl_parsed_hdr_t *cmd_info = ZB_BUF_GET_PARAM(param, zb_zcl_parsed_hdr_t);

  TRACE_MSG(TRACE_ZSE1, ">> zb_zcl_process_kec_specific_commands %hd", (FMT__H, param));

  if(ZB_ZCL_FRAME_DIRECTION_TO_SRV == cmd_info->cmd_direction)
  {
#ifdef ZB_SE_ENABLE_KEC_SERVER
    TRACE_MSG(TRACE_ZSE1, "<< zb_zcl_process_kec_specific_commands %hd - PROCESSING SERVER role", (FMT__H, param));
    return zb_zcl_process_kec_server_specific_commands(param);
#endif
  }
  else
  {
#ifdef ZB_SE_ENABLE_KEC_CLIENT
    TRACE_MSG(TRACE_ZSE1, "<< zb_zcl_process_kec_specific_commands %hd - PROCESSING client role", (FMT__H, param));
    return zb_zcl_process_kec_client_specific_commands(param);
#endif
  }
#if !defined ZB_SE_ENABLE_KEC_CLIENT || !defined ZB_SE_ENABLE_KEC_SERVER
  TRACE_MSG(TRACE_ZSE1, "<< zb_zcl_process_kec_specific_commands %hd - NOT PROCESSED, role not supported", (FMT__H, param));
  return ZB_FALSE;
#endif
}

/**
 *
 * Command to call user callback with passed status
 *
 * @param param - buffer reference or 0
 * @param status - status to pass to callback function
 *
 */
static void kec_call_user_cb(zb_uint8_t param, zb_uint16_t status)
{
  if(ZSE_CTXC().ke.user_cb == NULL)
  {
    if(param != 0U)
    {
      zb_buf_free(param);
    }
    return;
  }
  if(param == 0U)
  {
    zb_ret_t ret = zb_buf_get_out_delayed_ext(kec_call_user_cb, status, 0);
    if (ret != RET_OK)
    {
      TRACE_MSG(TRACE_ERROR, "Failed zb_buf_get_out_delayed_ext [%d]", (FMT__D, ret));
    }
  }
  else
  {
    ZSE_CTXC().commissioning.ke_term_info.status_code = (zb_uint8_t)status;
    zb_buf_set_status(param, (zb_int32_t)status);
    ZB_SCHEDULE_CALLBACK(ZSE_CTXC().ke.user_cb, param);
  }

#ifdef ZB_TH_ENABLED
  zse_kec_set_ch_cli_delays (0,0);
#endif /* ZB_TH_ENABLED */

}

/**
 *
 * Function saves server callback to global context
 *
 * @param cb - pointer to function
 *
 */
void zse_kec_set_server_cb(zb_callback2_t cb)
{
  ZSE_CTXC().ke.server_cb = cb;
}


/**
 *
 * Command to call user callback with passed status
 *
 * @param addr - short address of client
 * @param status - status to pass to server callback function
 *
 */
static void kec_call_srv_cb(zb_uint16_t addr, zb_uint8_t status)
{
  TRACE_MSG(TRACE_ZSE1, "kec_call_srv_cb cb %p addr 0x%x status %d", (FMT__P_D_D, ZSE_CTXC().ke.server_cb, addr, status));
  if(ZSE_CTXC().ke.server_cb != NULL)
  {
    zb_ret_t ret;
    zb_address_ieee_ref_t ref = (zb_address_ieee_ref_t)-1;

    ret = zb_address_by_short(addr, ZB_FALSE, ZB_FALSE, &ref);
    ZB_ASSERT(ret == RET_OK);
#ifdef SNCP_MODE
    /* to pass terminate status when CBKE initiated by remote device */
    ZSE_CTXC().commissioning.ke_term_info.status_code = status;
#endif
    ZB_SCHEDULE_CALLBACK2(ZSE_CTXC().ke.server_cb, ref, status);
  }
  ZSE_CTXC().ke.ke_status = ZB_FALSE;

#ifdef ZB_TH_ENABLED
  zse_kec_set_ch_srv_delays (0,0,0);
  KEC_CH_SKIP_MAC_CHECK = ZB_FALSE;
#endif /* ZB_TH_ENABLED */

}

#endif /* ZB_SE_ENABLE_KEC_CLUSTER */

#endif /* ZB_ENABLE_SE_MIN_CONFIG */
