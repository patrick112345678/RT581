/* ZBOSS Zigbee software protocol stack
 *
 * Copyright (c) 2012-2020 DSR Corporation, Denver CO, USA.
 * www.dsr-zboss.com
 * www.dsr-corporation.com
 * All rights reserved.
 *
 * This is unpublished proprietary source code of DSR Corporation
 * The copyright notice does not evidence any actual or intended
 * publication of such source code.
 *
 * ZBOSS is a registered trademark of Data Storage Research LLC d/b/a DSR
 * Corporation
 *
 * Commercial Usage
 * Licensees holding valid DSR Commercial licenses may use
 * this file in accordance with the DSR Commercial License
 * Agreement provided with the Software or, alternatively, in accordance
 * with the terms contained in a written agreement between you and
 * DSR.
 */
/* PURPOSE: Network tree routing
*/

#define ZB_TRACE_FILE_ID 2233
#include "zb_common.h"
#include "zb_scheduler.h"
#include "zb_mac.h"
#include "zb_nwk.h"
#include "zb_aps.h"
#include "nwk_internal.h"
#if defined NCP_MODE && !defined NCP_MODE_HOST
#include "zb_ncp.h"
#endif

#if defined ZB_NWK_MESH_ROUTING && defined ZB_ROUTER_ROLE
//#if 1

/*! \addtogroup ZB_NWK */
/*! @{ */

/* See 3.6.3 and doc/html/nwk/Zigbee-mesh-routing-interactive-tutorial.html */

/** \par Network mesh routing

    The mesh routing is based on AODV which uses route requests, replies,
    and path costs to determine the best route for transmission. The
    sequence goes something like this:

    - A route request command frame is generated by the source node and
    broadcast to the network.
    - The route request propagates over the whole network and eventually
    reaches the destination node.
    - The destination node will send a route reply command frame to the node
    that sent the request.
    - The node that received the route reply will unicast it to the node
    that sent it the route request.
    - The path will be followed until it reaches the originating node.
    The originating node will add the route to its routing table.

    \par Route discovery table

    The route discovery table is used for implementing route discovery
    in Zigbee. When trying to discover a route, route request command
    frames are sent out. To understand the usage of the route discovery
    table, its probably best to understand the sequence of events for
    route discovery:

    - A route request command frame is broadcast from the source node.
    - Each node that receives the route request will create a route
    discovery table entry with the route request info.
    - Each node will then broadcast-relay the route request.
    - When the route request reaches the destination node, then the
    destination node will generate a unicast route reply to the node
    that sent it the route request.
    - The node receiving the route reply will then unicast the route
    reply to the node that sent it the route request previously by looking
    up the info in the discovery table. It will also add the path cost
    which is also stored in the discovery table.
    - The reply will be unicast until it reaches the source node.
    - After the specified route discovery time, the route discovery
    entry will expire and be removed from the table.
*/

/* Parse mac header. Mac header offset saved inside buffer header, to be able to
 * get mac hdr data. Get source address if mac hdr exists, otherwise get device
 * source address */
static void nwk_get_mac_source_addr(zb_bufid_t b, zb_uint16_t *s)
{
    zb_uint16_t addr = nwk_get_pkt_mac_source(b);
    if (addr != ZB_MAC_SHORT_ADDR_NOT_ALLOCATED)
    {
        *s = addr;
        TRACE_MSG(TRACE_NWK3, "mac src 0x%x", (FMT__D, *s));
    }
    else
    {
        /* This is case when we are sending RREQ. Processing is common for both cases. */
        *s = ZB_PIBCACHE_NETWORK_ADDRESS();
        TRACE_MSG(TRACE_NWK3, "use our own address 0x%x as a source!", (FMT__D, *s));
    }
}


/* This function called periodically to find expired discovery table entries */
void zb_nwk_mesh_expiry_route_disc(zb_uint8_t param);
/* This function called periodically to find expired pending elements */
void zb_nwk_mesh_expiry_pending(zb_uint8_t param);

/**
   zb_nwk_mesh_send_pending_data

   Send a buffer from the pending list

   @param dest_addr - Destination address of pending packet
   @return nothing
 */
static void zb_nwk_mesh_send_pending_data(zb_uint16_t dest_addr);

void zb_nwk_mesh_routing_init()
{
    TRACE_MSG(TRACE_NWK1, ">> mesh_r_init", (FMT__0));

    if (ZB_U2B(ZB_PIBCACHE_RX_ON_WHEN_IDLE()))
    {
        /* Check for expired route discovery entries */
        TRACE_MSG(TRACE_NWK1, "schd r disc expiry", (FMT__0));
        ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_route_disc, 0, ZB_NWK_EXPIRY_ROUTE_DISCOVERY);

        /* Check for expired pending entries */
        TRACE_MSG(TRACE_NWK1, "schd pend expiry", (FMT__0));
        ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_pending, 0, ZB_NWK_EXPIRY_PENDING);
    }
    TRACE_MSG(TRACE_NWK1, "<< mesh_r_init", (FMT__0));
}

/*
 * Generate and send a route request command frame.
 * Add route request entry into the rreq list to be able to track this request.
*/
static void zb_nwk_mesh_send_rreq(zb_bufid_t cbuf, zb_nwk_cmd_rreq_t *nwk_cmd_rreq, zb_uint16_t src_addr, zb_uint8_t seq_num, zb_uint8_t path_cost, zb_uint8_t radius)
{
    TRACE_MSG(TRACE_ATM1, "Z< send route request", (FMT__0));
    TRACE_MSG(TRACE_NWK1, ">> send_rreq cbuf %p rreq %p s_addr %d path_cost %hd radius %hd", (FMT__P_P_D_H_H,
              cbuf, nwk_cmd_rreq, src_addr, path_cost, radius));

    {
        zb_nwk_hdr_t *nwhdr;
        zb_nwk_cmd_rreq_t *rreq_cmd;
        zb_bool_t secure;
        zb_uint8_t rreq_payload_size = (zb_uint8_t)sizeof(zb_nwk_cmd_rreq_t);

        secure = (zb_bool_t)(ZG->aps.authenticated
                             && ZB_U2B(ZB_NIB_SECURITY_LEVEL()));

        /* Check if the Route Request contains an optional Destination IEEE address field. */
        if (!ZB_U2B(ZB_NWK_GET_RREQ_HAS_DST_IEEE_ADDR(nwk_cmd_rreq->opt)))
        {
            rreq_payload_size -= (zb_uint8_t)sizeof(zb_ieee_addr_t);
        }

        nwhdr = nwk_alloc_and_fill_hdr(cbuf,
                                       src_addr, ZB_NWK_BROADCAST_ROUTER_COORDINATOR, ZB_FALSE, secure, ZB_TRUE, ZB_FALSE);
        rreq_cmd = (zb_nwk_cmd_rreq_t *)nwk_alloc_and_fill_cmd(cbuf, ZB_NWK_CMD_ROUTE_REQUEST, rreq_payload_size);

#ifdef ZB_PRO_STACK
        rreq_cmd->opt = nwk_cmd_rreq->opt & ZB_NWK_RREQ_OPT_SUPPORTED_BITS;
#else
        rreq_cmd->opt = 0;
#endif
        rreq_cmd->rreq_id = nwk_cmd_rreq->rreq_id;
        rreq_cmd->dest_addr = nwk_cmd_rreq->dest_addr;
        ZB_NWK_ADDR_TO_LE16(rreq_cmd->dest_addr);
        rreq_cmd->path_cost = path_cost;
        if (ZB_NWK_GET_RREQ_HAS_DST_IEEE_ADDR(rreq_cmd->opt) != 0U)
        {
            ZB_IEEE_ADDR_COPY(rreq_cmd->dest_long_addr, nwk_cmd_rreq->dest_long_addr);
        }
        nwhdr->radius = radius;
        //nwhdr->src_addr = src_addr;

        /* Not sure it is right, but let's assign original seq_num. Else request
         * can be dropped as a dup at receiver's side. */
        if (src_addr != ZB_PIBCACHE_NETWORK_ADDRESS())
        {
            nwhdr->seq_num = seq_num;
        }

        /* transmit route request packet */
        (void)zb_nwk_init_apsde_data_ind_params(cbuf, ZB_NWK_INTERNAL_NSDU_HANDLE);
        ZB_SCHEDULE_CALLBACK(zb_nwk_forward, cbuf);
#if defined NCP_MODE && !defined NCP_MODE_HOST && defined ZB_APSDE_REQ_ROUTING_FEATURES && defined ZB_NCP_ENABLE_ROUTING_IND
        ncp_nwk_route_req_send_ind(rreq_cmd);
#endif

    }

    TRACE_MSG(TRACE_NWK1, "<< send_rreq", (FMT__0));
}

/*
 * Generate and send a route reply command frame.
*/

static void zb_nwk_mesh_send_rrep(zb_bufid_t cbuf, zb_uint8_t rreq_id, zb_uint16_t originator, zb_uint16_t responder, zb_uint8_t path_cost, zb_uint16_t sender_addr, zb_uint8_t cmd_opt)
{
    zb_nwk_hdr_t *nwhdr;
    zb_nwk_cmd_rrep_t *rrep;
    zb_bool_t secure;
#if defined ZB_PRO_STACK && !defined ZB_NO_NWK_MULTICAST
    zb_uint8_t is_multicast = 0U;
#endif
    ZVUNUSED(cmd_opt);
    secure = ZG->aps.authenticated && (ZB_NIB_SECURITY_LEVEL() > 0U);
    TRACE_MSG(TRACE_NWK1, ">> send_rrep cbuf %p rreq_id %d orig %d resp %d p_cost %hd s_addr %d",
              (FMT__P_D_D_D_H_D, cbuf, rreq_id, originator, responder, path_cost, sender_addr));
    nwhdr = nwk_alloc_and_fill_hdr(cbuf, ZB_PIBCACHE_NETWORK_ADDRESS(), sender_addr, ZB_FALSE, secure,
                                   ZB_TRUE, ZB_FALSE);
    rrep = (zb_nwk_cmd_rrep_t *)nwk_alloc_and_fill_cmd(cbuf, ZB_NWK_CMD_ROUTE_REPLY,
            (zb_uint8_t)sizeof(zb_nwk_cmd_rrep_t));

    rrep->opt = 0U; /* AD: initial */
#if defined ZB_PRO_STACK && !defined ZB_NO_NWK_MULTICAST
    is_multicast = (cmd_opt & 0x40) ? (1) : (0); /* Get multicast flag from command options field (pos in 7b) */
    ZB_SET_RREP_MULTICAST(rrep->opt, is_multicast);
#endif

    rrep->rreq_id = rreq_id;
    rrep->originator = originator;
    rrep->responder = responder;
    rrep->path_cost = path_cost;
    nwhdr->radius = (zb_uint8_t)(ZB_NIB_MAX_DEPTH() << 1);
    ZB_NWK_ADDR_TO_LE16(rrep->originator);
    ZB_NWK_ADDR_TO_LE16(rrep->responder);

    (void)zb_nwk_init_apsde_data_ind_params(cbuf, ZB_NWK_INTERNAL_NSDU_HANDLE);
    ZB_SCHEDULE_CALLBACK(zb_nwk_forward, cbuf);

    TRACE_MSG(TRACE_NWK1, "<< snd_rrep", (FMT__0));
}

static void zb_clear_pending_table_for_dest_addr(zb_uint16_t dest_addr)
{
    zb_nwk_pend_t *ent;

    do
    {
        NWK_ARRAY_FIND_ENT(ZB_NIB().pending_table, ZB_NWK_PENDING_TABLE_SIZE, ent, (ent->dest_addr == dest_addr));
        if (ent != NULL)
        {
            /* Call failure confirm if needed. */
            if (ent->handle >= ZB_NWK_MINIMAL_INTERNAL_HANDLE)
            {
                TRACE_MSG(TRACE_ERROR, "Free internal pending entry, param %hd",
                          (FMT__H, ent->param));

                zb_buf_free(ent->param);
            }
            else
            {
                TRACE_MSG(TRACE_ERROR, "Call zb_nlde_data_confirm(), param %hd",
                          (FMT__H, ent->param));
                /* ZB_NWK_STATUS_ROUTE_ERROR to detect presence of NWK header and
                 * absence of MAC header in zb_nlde_data_confirm() */
                nwk_call_nlde_data_confirm(ent->param, ZB_NWK_STATUS_ROUTE_ERROR, ZB_TRUE);
            }
            /* Free the entry. */
            NWK_ARRAY_PUT_ENT(ZB_NIB().pending_table, ent, ZB_NIB().pending_table_cnt);
        }
    } while (ent != NULL);
}

/*
 * Sets up new route discovery operation.
 * Call rreq_handler to do a real discovery.
 */

void zb_nwk_mesh_route_discovery(zb_bufid_t cbuf, zb_uint16_t dest_addr, zb_uint8_t radius, zb_uint8_t rreq_type)
{
    zb_apsde_data_ind_params_t *data_ind;
    zb_nwk_hdr_t *nwk_hdr;
    zb_nwk_cmd_rreq_t *nwk_cmd_rreq;
    zb_nwk_routing_t *route;
    zb_uint8_t rreq_payload_size = (zb_uint8_t)sizeof(zb_ieee_addr_t);
    zb_address_ieee_ref_t addr_ref;
    zb_ieee_addr_t addr_long;
    zb_bool_t addr_long_found;

    TRACE_MSG(TRACE_NWK1, ">> route_discovery cbuf %p dest_addr %x radius %hd type %hd", (FMT__P_H_H_H, cbuf, dest_addr, radius, rreq_type));

    addr_long_found = (zb_address_by_short(dest_addr, ZB_FALSE, ZB_FALSE, &addr_ref) == RET_OK);
    if (addr_long_found)
    {
        zb_address_ieee_by_ref(addr_long, addr_ref);
        addr_long_found = ZB_IEEE_ADDR_IS_VALID(addr_long);
    }

    /* See 3.6.3.5 Route Discovery */

    route = zb_nwk_mesh_find_route(dest_addr);

    if (route != NULL && route->status == ZB_NWK_ROUTE_STATE_VALIDATION_UNDERWAY)
    {
        /* discovery process is already active, no need to initiate a new one */
        if (cbuf != 0U)
        {
            zb_buf_free(cbuf);
        }
    }
    else
    {
        /* allocate a buffer for a new route dicsovery request */
        if (cbuf == 0U)
        {
            if (!zb_buf_is_oom_state())
            {
                cbuf = zb_buf_get_out();
            }
            else
            {
                TRACE_MSG(TRACE_ERROR, "Oops - out of memory, can't initiate route disc", (FMT__0));
                zb_clear_pending_table_for_dest_addr(dest_addr);
            }
        }
    }

    if (cbuf != 0U)
    {
        /* alloc space for nwk header and rreq cmd */
        nwk_hdr = zb_buf_initial_alloc(cbuf, ZB_NWK_SHORT_HDR_SIZE(0));
#ifndef ZB_PRO_STACK
        rreq_payload_size -= sizeof(zb_ieee_addr_t);
#else
        if (!addr_long_found)
        {
            rreq_payload_size -= (zb_uint8_t)sizeof(zb_ieee_addr_t);
        }
#endif
        nwk_cmd_rreq = zb_buf_alloc_right(cbuf, rreq_payload_size);
        ZB_ASSERT(nwk_hdr != NULL && nwk_cmd_rreq != NULL);

        /* fill meaningful hdr and command parameters for rrreq handler */
        nwk_cmd_rreq->rreq_id = ZB_NWK_GET_RREQ_ID();
        nwk_cmd_rreq->dest_addr = dest_addr;
        nwk_cmd_rreq->path_cost = 0;
        nwk_cmd_rreq->opt = 0;

        ZB_NWK_SET_RREQ_TYPE(nwk_cmd_rreq->opt, rreq_type);
#if defined ZB_PRO_STACK && !defined ZB_NO_NWK_MULTICAST
        /*
         * 'is_multicast' was a parameter of this function but it was removed a long
         * time ago. Replace with '1' in order to compile the code.
         */
        ZB_SET_RREQ_MULTICAST(nwk_cmd_rreq->opt, 1);
#endif

        /* Include IEEE address if it is known.
         * See: Zigbee PRO R22 specification, section 3.4.1.3.1
         */
        if (addr_long_found)
        {
            ZB_NWK_SET_RREQ_HAS_DST_IEEE_ADDR(nwk_cmd_rreq->opt, 1U);
            zb_address_ieee_by_ref(nwk_cmd_rreq->dest_long_addr, addr_ref);
        }

        /* default radius = 2 * max depth */
        nwk_hdr->radius = radius > 0U ? radius : (zb_uint8_t)(ZB_NIB().max_depth << 1);
        nwk_hdr->src_addr = ZB_PIBCACHE_NETWORK_ADDRESS();

        /* it's outgoing RREQ */
        data_ind = ZB_BUF_GET_PARAM(cbuf, zb_apsde_data_ind_params_t);
        data_ind->mac_src_addr = ZB_MAC_SHORT_ADDR_NOT_ALLOCATED;

        zb_nwk_mesh_rreq_handler(cbuf, nwk_hdr, nwk_cmd_rreq);
    }

    TRACE_MSG(TRACE_NWK1, "<< route_discovery", (FMT__0));
}


static void nwk_clear_pending_table_entry(zb_nwk_pend_t *ent)
{
    /* Call failure confirm if needed. */
    if (ent->handle >= ZB_NWK_MINIMAL_INTERNAL_HANDLE)
    {
        TRACE_MSG(TRACE_ERROR, "Free internal pending entry, param %hd",
                  (FMT__H, ent->param));

        zb_buf_free(ent->param);
    }
    else
    {
        TRACE_MSG(TRACE_ERROR, "Call zb_nlde_data_confirm(), param %hd",
                  (FMT__H, ent->param));
        /* ZB_NWK_STATUS_ROUTE_ERROR to detect presence of NWK header and
         * absence of MAC header in zb_nlde_data_confirm() */
        nwk_call_nlde_data_confirm(ent->param, ZB_NWK_STATUS_ROUTE_ERROR, ZB_TRUE);
    }

    /* Free the entry. */
    NWK_ARRAY_PUT_ENT(ZB_NIB().pending_table, ent, ZB_NIB().pending_table_cnt);
}


void nwk_clear_pending_table_for_destination(zb_uint16_t dst_addr)
{
    zb_uint_t i;

    for (i = 0; i < ZB_NWK_PENDING_TABLE_SIZE; i++)
    {
        if (ZB_U2B(ZB_NIB().pending_table[i].used)
                && ZB_NIB().pending_table[i].dest_addr == dst_addr)
        {
            nwk_clear_pending_table_entry(&ZB_NIB().pending_table[i]);
        }
    }
}


void nwk_clear_pending_table(void)
{
    zb_uint_t i;

    for (i = 0; i < ZB_NWK_PENDING_TABLE_SIZE; i++)
    {
        if (ZB_U2B(ZB_NIB().pending_table[i].used))
        {
            nwk_clear_pending_table_entry(&ZB_NIB().pending_table[i]);
        }
    }
}



zb_nwk_routing_t *new_routing_table_ent(void)
{
    zb_uindex_t i;
    zb_nwk_routing_t *ent = NULL;

    for (i = 0; i < ZB_NWK_ROUTING_TABLE_SIZE; i++)
    {
        if (!ZB_U2B(ZB_NIB().routing_table[i].used))
        {
            ent = &ZB_NIB().routing_table[i];
            ZB_NIB().routing_table_cnt++;
            ZB_NIB().routing_table[i].used = ZB_TRUE_U;
            break;
        }
    }
    return ent;
}

/* GP add, start */
zb_uint8_t zb_nwk_routing_table_size()
{
    zb_uindex_t i;
    zb_uint8_t cnt = 0;
    for (i = 0 ; i < ZB_NWK_ROUTING_TABLE_SIZE ; i++)
    {
        cnt += ZB_NIB().routing_table[i].used;
    }

    return cnt;
}
/* GP add, end */

#ifdef ZB_PRO_STACK
static void add_rev_route(zb_uint16_t rev_addr, zb_uint16_t next_hop, zb_uint8_t rreq_type)
{
    zb_bool_t created_new = ZB_FALSE;
    zb_neighbor_tbl_ent_t *nbt;
    zb_address_ieee_ref_t ref;
    zb_nwk_routing_t *rev_routing_ent; /*AD: reverse routing entry, also check expiration to get how
                                      * it works*/

    TRACE_MSG(TRACE_NWK1, "> add_rev_route", (FMT__0));

    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, rev_routing_ent,
                       (rev_routing_ent->dest_addr == rev_addr));

    if (rev_routing_ent == NULL)
    {
        if (zb_nwk_neighbor_get_by_short(rev_addr, &nbt) != RET_OK
                /* Do not setup rev route to our neighbor normally. But for the test
                * TP_PRO_BV-04 must do it. */
#ifdef ZB_CERTIFICATION_HACKS
                || (ZB_CERT_HACKS().use_route_for_neighbor != 0U
                    && !(nbt->device_type == ZB_NWK_DEVICE_TYPE_ED
                         && nbt->relationship == ZB_NWK_RELATIONSHIP_CHILD))
#endif /* ZB_CERTIFICATION_HACKS */
           )
        {
            rev_routing_ent = new_routing_table_ent();
            created_new = ZB_TRUE;
        }
    }

    if (rev_routing_ent != NULL)
    {
        zb_ret_t ret_addr_by_short;

#ifndef ZB_NO_NWK_MULTICAST
        rev_routing_ent->group_id_flag = 0;
#endif /* ZB_NO_NWK_MULTICAST */
        rev_routing_ent->dest_addr = rev_addr;
        rev_routing_ent->status = ZB_NWK_ROUTE_STATE_ACTIVE;
        rev_routing_ent->expiry = ZB_NWK_ROUTING_TABLE_EXPIRY;

        /* FIXME: A proper error handling should be implemented to solve errors in Release, track in ZOI-508 */
        ret_addr_by_short = zb_address_by_short(next_hop, ZB_TRUE, ZB_FALSE, &ref);
        ZB_ASSERT(ret_addr_by_short == RET_OK);
#ifndef ZB_LITE_NO_SOURCE_ROUTING
        rev_routing_ent->many_to_one = ZB_B2U(rreq_type != ZB_NWK_RREQ_TYPE_NOT_MTORR);
        rev_routing_ent->no_route_cache = ZB_B2U(rreq_type == ZB_NWK_RREQ_TYPE_MTORR_RREC_TABLE_UNSUPPORTED);

        /* If the frame is a many-to-one route request and if the routing table entry is new,
           or if the no route cache flag is set to TRUE, or if the next hop field changed,
           the route record required field shall be set to TRUE, otherwise it remains unchanged.
        */
        if (rreq_type != ZB_NWK_RREQ_TYPE_NOT_MTORR)
        {
            if (created_new ||
                    ZB_U2B(rev_routing_ent->no_route_cache) ||
                    rev_routing_ent->next_hop_addr_ref != ref)
            {
                rev_routing_ent->route_record_required = ZB_TRUE;
            }
        }
        else
        {
            rev_routing_ent->route_record_required = ZB_FALSE;
        }
#endif /* ZB_LITE_NO_SOURCE_ROUTING */
        rev_routing_ent->next_hop_addr_ref = ref;

        TRACE_MSG(TRACE_NWK3, "assign rev route ent %p dst 0x%x next_hop_ref %hd",
                  (FMT__P_D_H, rev_routing_ent, rev_routing_ent->dest_addr, rev_routing_ent->next_hop_addr_ref));
    }
    else
    {
        TRACE_MSG(TRACE_NWK3, "do not assign rev route to out neighbor 0x%x",
                  (FMT__D, rev_addr));
    }

    TRACE_MSG(TRACE_NWK1, "< add_rev_route", (FMT__0));
}
#endif


/*
  Process an incoming route request and decide if it needs to be forwarded
  or a route reply needs to be generated. This function will check the
  discovery table to see if we received the same route request previously.
  If we did, then it will compare the path cost to see if the incoming route
  request has a more efficient path. If so, then it will replace the discovery
  entry info with the info from this route request.

  If its a new route request, then it will create a route discovery entry and a
  routing table entry. It will then check to see if its the destination. If so, then
  a route reply will be sent. Otherwise, it will relay the route request via
  broadcast.
*/
void zb_nwk_mesh_rreq_handler(zb_bufid_t buf, zb_nwk_hdr_t *nwk_hdr, zb_nwk_cmd_rreq_t *nwk_cmd_rreq)
{
    zb_ret_t ret = RET_OK;
    zb_uint8_t path_cost;
    zb_uint8_t hop_cost;
    zb_nwk_route_discovery_t *disc_ent = NULL;
    zb_nwk_routing_t *routing_ent = NULL;
    zb_uint16_t mac_src;

    TRACE_MSG(TRACE_NWK1, ">> rreq_handler buf %p hdr %p cmdopt 0x%x", (FMT__P_P_H, buf, nwk_hdr, nwk_cmd_rreq->opt));

    /* NK:
       1. When coordinator/router receives Route Request to themself or its neighbor,
       we do not need to create routing_table entry.
       2. When coordinator/router receives Route Request neither to themself nor to
       its neighbor, we need to create route_disc_table entry (according to spec).
       Need to discuss behaviour of device in this case.
    */

    /* Note: this call gets frame source if this is incoming RREQ or our source if
     * this is our outgoing RREQ */
    nwk_get_mac_source_addr(buf, &mac_src);

    /* calc path cost: get from nbt, calculate it using LQI */
    /*
    For many-to-one route requests, and for regular route requests if the nwkSymLink
    attribute is TRUE, upon receipt of a route request command frame, the neighbor
    table is searched for an entry corresponding to the transmitting device. If no such
    entry is found, or if the outgoing cost field of the entry has a value of 0, the frame
    is discarded and route request processing is terminated.
     */
    /*
    The maximum of the
    incoming and outgoing costs for the neighbor is used for the purposes of the path
    cost calculation, instead of the incoming cost.
     */
    /*
    If the device is not the destination of the route request command frame, the device
    shall compute the link cost from the previous device that transmitted the frame, as
    described in sub-clause 3.6.3.1.
     */
    hop_cost = path_cost = zb_nwk_calc_path_cost(mac_src);
    TRACE_MSG(TRACE_NWK3, "path_cost from previous dev 0x%x %hd", (FMT__D_H, mac_src, path_cost));
    if (path_cost == ZB_NWK_STATIC_PATH_COST + 1U)
    {
        TRACE_MSG(TRACE_NWK1, "no nbt, drop this RREQ", (FMT__0));
        goto done;
    }
    /*
    the forward cost field, which is determined by using the previous sender of the
    command frame to compute the link cost, as described in sub-clause 3.6.3.1, and
    adding it to the path cost contained the route request command frame.
     */
    path_cost += nwk_cmd_rreq->path_cost;
    TRACE_MSG(TRACE_NWK3, "total path_cost %hd", (FMT__H, path_cost));

    /* search in routing table */

    /*
      a) case of sending RREQ
    3.6.3.5.1 Initiation of Route Discovery

      b) processing of incoming RREQ
    3.6.3.5.2 Upon Receipt of a Route Request Command Frame
    */

    /*
    a)
    If the device initiating route discovery has no routing table entry corresponding to
    the routing address of the destination device, it shall establish a routing table entry
    with status equal to DISCOVERY_UNDERWAY.
    */

    /*
    If neither the device nor one of its end device children is
    the destination of the route request command frame, the device shall determine if
    a route discovery table (see Table 3.53) entry exists with the same route request
    identifier and source address field. If no such entry exists, one shall be created.
       */

    TRACE_MSG(TRACE_NWK1, "dst_addr 0x%x", (FMT__D, nwk_cmd_rreq->dest_addr));

    NWK_ARRAY_FIND_ENT( ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, routing_ent, (routing_ent->dest_addr == nwk_cmd_rreq->dest_addr) );

    if ( routing_ent != NULL )
    {
        TRACE_MSG(TRACE_NWK1, "routing table ent found, state %d", (FMT__D, routing_ent->status));
        if ( (routing_ent->status != ZB_NWK_ROUTE_STATE_ACTIVE)
                && (routing_ent->status != ZB_NWK_ROUTE_STATE_VALIDATION_UNDERWAY) )
        {
            /*
            If a routing table entry
            corresponding to the routing address of the destination exists and its status is not
            ACTIVE or VALIDATION_UNDERWAY, the status shall be set to
            DISCOVERY_UNDERWAY.
             */
            routing_ent->status = ZB_NWK_ROUTE_STATE_DISCOVERY_UNDERWAY;
            TRACE_MSG(TRACE_NWK1, "change r ent state to dsc uway", (FMT__0));
        }
    }
    else
    {
        TRACE_MSG(TRACE_NWK1, "no routing entry found, add new", (FMT__0));
        /* add new routing entry */

        /*
        If no such entry exists and the frame is a unicast
        route request, an entry shall be created and its status set to
        DISCOVERY_UNDERWAY.
         */

        routing_ent = new_routing_table_ent();
        if ( routing_ent != NULL )
        {
            routing_ent->dest_addr = nwk_cmd_rreq->dest_addr;
            routing_ent->status = ZB_NWK_ROUTE_STATE_DISCOVERY_UNDERWAY;
#if defined ZB_PRO_STACK && !defined ZB_NO_NWK_MULTICAST
            routing_ent->group_id_flag = ZB_GET_RREQ_MULTICAST(nwk_cmd_rreq->opt);
#endif
            routing_ent->expiry = ZB_NWK_ROUTING_TABLE_EXPIRY;
            TRACE_MSG(TRACE_NWK1, "new routing ent : dest_addr 0x%x status %hd next_hop %hd",
                      (FMT__D_H_H,
                       routing_ent->dest_addr, routing_ent->status, routing_ent->next_hop_addr_ref));
        }
        else
        {
            ret = RET_NO_MEMORY;
            TRACE_MSG(TRACE_ERROR, "no room for r ent, skip rreq", (FMT__0));
            goto done;
        }
    }

    /*
    the device
    shall determine if a route discovery table (see Table 3.53) entry exists with the
    same route request identifier and source address field. If no such entry exists, one
    shall be created.
     */

    /* search thought discovery table */
    TRACE_MSG(TRACE_NWK1, "rreq_id %hd src_addr 0x%x", (FMT__H_D, nwk_cmd_rreq->rreq_id, nwk_hdr->src_addr));
    NWK_ARRAY_FIND_ENT( ZB_NIB().route_disc_table, ZB_NWK_ROUTE_DISCOVERY_TABLE_SIZE, disc_ent,
                        (disc_ent->request_id == nwk_cmd_rreq->rreq_id) && (disc_ent->source_addr == nwk_hdr->src_addr) );
    if ( disc_ent != NULL )
    {
        TRACE_MSG(TRACE_NWK1, "disc_ent %p found, new path_cost %hd old forward_cost %hd", (FMT__P_H_H, disc_ent, path_cost, disc_ent->forward_cost));
        /* check path cost and update route disc entry */
        if ( path_cost < disc_ent->forward_cost )
        {
            TRACE_MSG(TRACE_NWK1, "new forward_cost %hd old sender_addr 0x%x new sender_addr 0x%x",
                      (FMT__H_D_D, path_cost, disc_ent->sender_addr, mac_src));
            /* replace route with better one */
            disc_ent->sender_addr = mac_src;
            /*
            The result
            of the above calculation is stored in the forward cost field of the newly created
            route discovery table entry.
             */
            disc_ent->forward_cost = path_cost;
        }
        else
        {
            /* this is normal case, do not change ret code */

            /* This code skips path with better cost or RREQ packet dups (I hope) */
            TRACE_MSG(TRACE_NWK1, "we have better or same path, skip this rreq", (FMT__0));
            goto done;
        }
    }
    else
    {
        TRACE_MSG(TRACE_NWK1, "no disc ent, try to add new", (FMT__0));
        /* add new discovery entry */

        /*
        When creating the route discovery table entry, the fields are set to the
        corresponding values in the route request command frame. The only exception is
        the forward cost field, which is determined by using the previous sender of the
        command frame to compute the link cost, as described in sub-clause 3.6.3.1, and
        adding it to the path cost contained the route request command frame. The result
        of the above calculation is stored in the forward cost field of the newly created
        route discovery table entry.
         */

        NWK_ARRAY_GET_ENT(ZB_NIB().route_disc_table, disc_ent, ZB_NIB().route_disc_table_cnt);
        if ( disc_ent != NULL )
        {
            TRACE_MSG(TRACE_NWK1, "Create route disc entry %p", (FMT__P, disc_ent));
            disc_ent->request_id       = nwk_cmd_rreq->rreq_id;
            disc_ent->source_addr      = nwk_hdr->src_addr;
            disc_ent->sender_addr      = mac_src;
            disc_ent->dest_addr        = nwk_cmd_rreq->dest_addr;
            disc_ent->forward_cost     = path_cost;
            disc_ent->residual_cost    = 0xff;
            disc_ent->expiration_time  = ZB_NWK_ROUTE_DISCOVERY_EXPIRY;
            TRACE_MSG(TRACE_NWK1, "disc ent added: request_id %hd src_addr 0x%x sndr_addr 0x%x d_addr 0x%x fwd_cost %hd res_cost %hd exp_time %d", (FMT__H_D_D_D_H_H_D,
                      disc_ent->request_id, disc_ent->source_addr, disc_ent->sender_addr, disc_ent->dest_addr,
                      disc_ent->forward_cost, disc_ent->residual_cost, disc_ent->expiration_time));
        }
        else
        {
            ret = RET_NO_MEMORY;
            TRACE_MSG(TRACE_ERROR, "no room for discovery ent, skip rreq", (FMT__0));
            goto done;
        }
    }


    /*
    If the nwkSymLink attribute is set to TRUE, the device
    shall also create a routing table entry with the destination address field set to the
    source address of the route request command frame and the next hop field set to
    the address of the previous device that transmitted the command frame. The status
    field shall be set to ACTIVE.
     */
#ifdef ZB_PRO_STACK
    add_rev_route(nwk_hdr->src_addr, mac_src, ZB_NWK_GET_RREQ_TYPE(nwk_cmd_rreq->opt));
#endif

    /*
    the device shall check if it is the destination of the command frame by
    comparing the destination address field of the route request command frame
    payload with its own address. It shall also check if the destination of the command
    frame is one of its end device children by comparing the destination address field
    of the route request command frame payload with the address of each of its end
    device children, if any.
    */

    /* Check that this is outgoing request */
    if (mac_src != ZB_PIBCACHE_NETWORK_ADDRESS())
    {
        /* Check that this rreq is for us or our neighbour and not MTORR, send route reply in this
         * case, forward route request otherwise.

         * Note: zb_nwk_calc_path_cost returns ZB_NWK_STATIC_PATH_COST + 1 if
         * device is not our neighbor
         */
        zb_uint8_t add_cost = zb_nwk_calc_path_cost(nwk_cmd_rreq->dest_addr);
        if (
#if defined ZB_PRO_STACK && !defined ZB_NO_NWK_MULTICAST
            (ZB_GET_RREQ_MULTICAST(nwk_cmd_rreq->opt) && zb_aps_is_in_group(nwk_cmd_rreq->dest_addr))
            ||
            (!ZB_GET_RREQ_MULTICAST(nwk_cmd_rreq->opt) &&
#else
            (
#endif
             /* if nwk_cmd_rreq->dest_addr == ZB_PIBCACHE_NETWORK_ADDRESS() (req to us), add_cost
              * will be 0 */
             (ZB_NWK_GET_RREQ_TYPE(nwk_cmd_rreq->opt) == ZB_NWK_RREQ_TYPE_NOT_MTORR &&
              add_cost != ZB_NWK_STATIC_PATH_COST + 1U)))
        {
            /* Cost in RREP is cost to our neighbor + cost for the next hop */
            add_cost += hop_cost;

            TRACE_MSG(TRACE_NWK1, "this rreq for us or neighbor or for our group, send rrep cost %hd", (FMT__H, add_cost));
            zb_nwk_mesh_send_rrep(buf, nwk_cmd_rreq->rreq_id, nwk_hdr->src_addr, nwk_cmd_rreq->dest_addr, add_cost,
                                  mac_src, nwk_cmd_rreq->opt);

            /* zb_nwk_mesh_send_rrep is now responsible for buffer */
            buf = 0;
        }
    }

    /* Send route request if route reply had not already sent. */
    if (buf != 0U)
    {
#ifdef ZB_REDUCE_NWK_LOAD_ON_LOW_MEMORY
        if (zb_buf_memory_close_to_low())
        {
            /* Do not forward the request if memory is close to low - it is expensive operation (in
             * terms of network load). */
            ret = RET_NO_MEMORY;
            TRACE_MSG(TRACE_NWK1, "memory is close to low! Do not send rrec", (FMT__0));
        }
        else
#endif
        {
            /* Buffer will be modified inside zb_nwk_mesh_send_rreq, save data we
             * need */
            zb_nwk_cmd_rreq_t nwk_cmd_rreq_save;
            ZB_MEMCPY(&nwk_cmd_rreq_save, nwk_cmd_rreq, sizeof(nwk_cmd_rreq_save));

            TRACE_MSG(TRACE_NWK1, "don't know rreq dest, prop it", (FMT__0));

            if (nwk_hdr->radius > 0U)
            {
                (void)zb_nwk_mesh_send_rreq(buf, &nwk_cmd_rreq_save, nwk_hdr->src_addr, nwk_hdr->seq_num, path_cost, nwk_hdr->radius);
                /* zb_nwk_mesh_send_rreq is now responsible for buffer */
                buf = 0;
            }
        }
    }

done:
    if ( ret != RET_OK )
    {
        TRACE_MSG(TRACE_NWK1, "error %d above, rm disc and r ent if", (FMT__D, ret));
        if ( disc_ent != NULL )
        {
            NWK_ARRAY_PUT_ENT(ZB_NIB().route_disc_table, disc_ent, ZB_NIB().route_disc_table_cnt);
            TRACE_MSG(TRACE_NWK1, "Clear route disc entry %p", (FMT__P, disc_ent));
        }
        if ( routing_ent != NULL )
        {
            NWK_ARRAY_PUT_ENT(ZB_NIB().routing_table, routing_ent, ZB_NIB().routing_table_cnt);
            TRACE_MSG(TRACE_NWK1, "Clear routing entry %p", (FMT__P, routing_ent));
        }

#ifndef ZB_LITE_NO_NLME_ROUTE_DISCOVERY
        /* if this request was initiated by APS, confirm that route discovery failed */
        if ( ZB_U2B(ZB_NIB().aps_rreq_addr)
                && ZB_NIB().aps_rreq_addr == nwk_cmd_rreq->dest_addr )
        {
            nwk_route_discovery_confirm(buf, ZB_NWK_COMMAND_STATUS_NO_ROUTE_AVAILABLE);
            /* prevent buffer from being free */
            buf = 0;
            ZB_NIB().aps_rreq_addr = (zb_uint16_t) -1;
        }
#endif
    }

    if ( buf != 0U )
    {
        TRACE_MSG(TRACE_NWK1, "free buf %hd", (FMT__H, buf));
        zb_buf_free(buf);
    }
    TRACE_MSG(TRACE_NWK1, "<< rreq_handler", (FMT__0));
}

#ifdef ZB_CERTIFICATION_HACKS
static void zb_nwk_mesh_send_pending_data_cert(zb_bufid_t param, zb_uint16_t dest_addr);

static void zb_nwk_mesh_send_pending_data_delayed(zb_bufid_t param)
{
    zb_nwk_mesh_send_pending_data_cert(param, 0);
}

static void zb_nwk_mesh_send_pending_data_cert(zb_bufid_t param, zb_uint16_t dest_addr)
{
    static zb_uint16_t addr = 0;

    if (!param)
    {
        /* Store the destination address and wait a timeout */
        addr = dest_addr;
        if (ZB_U2B(ZB_PIBCACHE_RX_ON_WHEN_IDLE()))
        {
            ZB_SCHEDULE_ALARM(zb_nwk_mesh_send_pending_data_delayed, ZB_TRUE, ZB_MILLISECONDS_TO_BEACON_INTERVAL(ZB_NWK_SEND_AFTER_RRESP_RECV_DELAY_MS));
        }
    }
    else
    {
        /* Send pending data */
        zb_nwk_mesh_send_pending_data(addr);
    }
}
#endif /* ZB_CERTIFICATION_HACKS */

/*
 * Process an incoming route reply.
 * First we need to make sure that we have a discovery table and routing table
 * entries for this route reply. If not or if path cost is greater than what we
 * have, then discard route reply.
 * If the route reply is for us, then end the route discovery process and send
 * out any frames that are buffered in the pending list. Otherwise, forward the
 * route reply to the sender of the route request as recorded in the discover
 * table entry.
 */
void zb_nwk_mesh_rrep_handler(zb_bufid_t buf, zb_nwk_hdr_t *nwk_hdr, zb_nwk_cmd_rrep_t *nwk_cmd_rrep)
{
    zb_uint8_t path_cost;
    zb_nwk_route_discovery_t *disc_ent;
    zb_nwk_routing_t *routing_ent;
    zb_uint16_t src_addr;

    ZVUNUSED(nwk_hdr);
    TRACE_MSG(TRACE_NWK1, ">> rrep_handler buf %p nwk_hdr %p nwk_cmd_rrep %p", (FMT__P_P_P, buf, nwk_hdr, nwk_cmd_rrep));

    /* parse mac header to get source address */
    nwk_get_mac_source_addr(buf, &src_addr);

    /* find proper discovery and routing table entries, calculate path cost */
    TRACE_MSG(TRACE_NWK1, "rrep cmd: rreq_id %hd orig 0x%x resp 0x%x src_addr 0x%x / 0x%x",
              (FMT__H_D_D_D_D, nwk_cmd_rrep->rreq_id, nwk_cmd_rrep->originator, nwk_cmd_rrep->responder,
               src_addr, nwk_hdr->src_addr));

    path_cost = nwk_cmd_rrep->path_cost;
    TRACE_MSG(TRACE_NWK1, "total path_cost %hd", (FMT__H, path_cost));
    ZB_NWK_ADDR_TO_LE16(nwk_cmd_rrep->responder);
    ZB_NWK_ADDR_TO_LE16(nwk_cmd_rrep->originator);
    NWK_ARRAY_FIND_ENT( ZB_NIB().route_disc_table, ZB_NWK_ROUTE_DISCOVERY_TABLE_SIZE, disc_ent,
                        (disc_ent->request_id == nwk_cmd_rrep->rreq_id) && (disc_ent->source_addr == nwk_cmd_rrep->originator) );

    /*
      If the receiving device has routing capacity, it shall check whether it is the
      destination of the route reply command frame by comparing the contents of the
      originator address field of the command frame payload with its own address. If it
      is, it shall search its route discovery table for an entry corresponding to the route
      request identifier in the route reply command frame payload.
    */

    if (disc_ent != NULL)
    {
        TRACE_MSG(TRACE_NWK3, "disc tbl ent: source 0x%x, sender 0x%x, dst 0x%x, used %hd",
                  (FMT__D_D_D_H, disc_ent->source_addr, disc_ent->sender_addr, disc_ent->dest_addr, disc_ent->used));
    }

    NWK_ARRAY_FIND_ENT( ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, routing_ent,
                        (routing_ent->dest_addr == nwk_cmd_rrep->responder) );

    TRACE_MSG(TRACE_NWK1, "p_cost %d disc_ent %p r_ent %p residual_cost %hd",
              (FMT__D_P_P_H,
               path_cost, disc_ent, routing_ent, disc_ent ? disc_ent->residual_cost : 0));


    /*
      If a route discovery table entry exists, the device
      shall search its routing table for an entry with a destination address field equal to
      the routing address corresponding to the responder address in the route reply
      command frame. If there is no such routing table entry, the route reply command
      frame shall be discarded and, if a route discovery table entry corresponding to the
      route request identifier in the route reply command frame exists, it shall also be
      removed and route reply processing shall be terminated
    */
    if (routing_ent != NULL)
    {
        TRACE_MSG(TRACE_NWK3, "routing ent dst 0x%x next_hop_ref %hd used %hd status %hd",
                  (FMT__D_H_H_H, routing_ent->dest_addr, routing_ent->next_hop_addr_ref, routing_ent->used, routing_ent->status));
    }

    /*
      If
      a route discovery table entry exists, the path cost value in the route reply
      command frame and the residual cost field in the route discovery table entry shall
      be compared. If the route discovery table entry value is less than the route reply
      value, the route reply command frame shall be discarded.
    */

    /* check response is meaningful for us */
    if ( disc_ent == NULL
            || routing_ent == NULL
            || path_cost > disc_ent->residual_cost )
    {
        /*
          If there is no such
          entry, the route reply command frame shall be discarded and route reply
          processing shall be terminated.
        */

        TRACE_MSG(TRACE_NWK1, "drop rresp, no purpose ent fnd or path too long", (FMT__0));
        if ( disc_ent == NULL || routing_ent == NULL )
        {
            TRACE_MSG(TRACE_NWK1, "one of disc or r ent is absent, free other", (FMT__0));
            if ( disc_ent != NULL )
            {
                TRACE_MSG(TRACE_NWK1, "Clear route disc entry %p", (FMT__P, disc_ent));
                NWK_ARRAY_PUT_ENT(ZB_NIB().route_disc_table, disc_ent, ZB_NIB().route_disc_table_cnt); /* Free array element */
            }
            if ( routing_ent != NULL )
            {
                NWK_ARRAY_PUT_ENT(ZB_NIB().routing_table, routing_ent, ZB_NIB().routing_table_cnt);
            }
            else
            {
                TRACE_MSG(TRACE_NWK3, "route entry in table not found for reply with addr: %hd", (FMT__H, nwk_cmd_rrep->responder));
            }
        }
        goto done;
    }

    /*
      If a routing table entry
      and a route discovery table entry exist and if the status field of the routing table
      entry is set to DISCOVERY_UNDERWAY, it shall be changed to
      VALIDATION_UNDERWAY if the routing table entrys GroupId flag is TRUE or
      to ACTIVE otherwise; the next hop field in the routing table shall be set to the
      previous device that forwarded the route reply command frame. The residual cost
      field in the route discovery table entry shall be set to the path cost field in the route
      reply payload.
    */
    {
        zb_ret_t ret;
        zb_address_ieee_ref_t ref;

        ret = zb_address_by_short(src_addr, ZB_TRUE, ZB_FALSE, &ref);
        if (ret != RET_OK)
        {
            /* Address not found, stop execution */
            ZB_ASSERT(ZB_FALSE);
            goto done;
        }
        routing_ent->next_hop_addr_ref = ref;
    }
    /* update route and discovery entries */
    disc_ent->residual_cost    = path_cost;
    disc_ent->expiration_time  = ZB_NWK_ROUTE_DISCOVERY_EXPIRY;

    TRACE_MSG(TRACE_NWK3, "assign routing ent %p next_hop_ref %hd",
              (FMT__P_H, routing_ent, routing_ent->next_hop_addr_ref));
    if (routing_ent->status == ZB_NWK_ROUTE_STATE_DISCOVERY_UNDERWAY)
    {
#ifndef ZB_NO_NWK_MULTICAST
        routing_ent->status = routing_ent->group_id_flag ? ZB_NWK_ROUTE_STATE_VALIDATION_UNDERWAY : ZB_NWK_ROUTE_STATE_ACTIVE;
#else
        routing_ent->status = ZB_NWK_ROUTE_STATE_ACTIVE;
#endif
    }

    /* check if rrep is for us */
    if ( nwk_cmd_rrep->originator == ZB_PIBCACHE_NETWORK_ADDRESS() )
    {
        TRACE_MSG(TRACE_NWK1, "got rrepl for our rreq, snd wait pckts", (FMT__0));

#if defined NCP_MODE && !defined NCP_MODE_HOST && defined ZB_APSDE_REQ_ROUTING_FEATURES && defined ZB_NCP_ENABLE_ROUTING_IND
        ncp_route_reply_ind(nwk_cmd_rrep);
#endif

        /*
          3.6.3.5.3 Upon Receipt of a Route Reply Command Frame

          Note that NLDE data requests may be processed as soon as the first valid route is
          determined.
        */

        /* Route discovery is complete. Now we have a new route. Go throught pending
         * queue to find packet to be forwarded */
        /* Normally send pending data immediately after receiving route resp.
           It is more robust and enough in the real life.
           But for test TP_PRO_BV-04 with assimertical links wait a bit to have a
           chance to collect better routes.
        */
#ifdef ZB_CERTIFICATION_HACKS
        if (ZB_CERT_HACKS().delay_pending_tx_on_rresp)
        {
            ZB_SCHEDULE_CALLBACK2(zb_nwk_mesh_send_pending_data_cert, ZB_FALSE, routing_ent->dest_addr);
        }
        else
#endif
        {
            /* In the real life send pending packets immediately */
            zb_nwk_mesh_send_pending_data(routing_ent->dest_addr);
        }
#ifndef ZB_LITE_NO_NLME_ROUTE_DISCOVERY
        /* if the request was initiated by APS, confirm that route discovery failed */
        TRACE_MSG(TRACE_NWK1, "aps_rreq_addr %d  dst_addr %d", (FMT__D_D, ZB_NIB().aps_rreq_addr, routing_ent->dest_addr));
        if ( ZB_NIB().aps_rreq_addr == routing_ent->dest_addr )
        {
            nwk_route_discovery_confirm(buf, ZB_NWK_STATUS_SUCCESS);
            buf = 0; /* ensure the buffer will not be freed */
            ZB_NIB().aps_rreq_addr = (zb_uint16_t) -1;
        }
#endif
    }
    else
    {
        /* forward */
        TRACE_MSG(TRACE_NWK1, "frwd rrep to the %d address", (FMT__D, disc_ent->sender_addr));

        /*
          After updating its own route entry, the device shall forward the route reply to the
          destination. Before forwarding the route reply, the path cost value shall be
          updated. The sender shall find the next hop to the route replys destination by
          searching its route discovery table for the entry matching the route request
          identifier and the source address and extracting the sender address. It shall use this
          next hop address to compute the link cost as described in sub-clause 3.6.3.1. This
          cost shall be added to the path cost field in the route reply.
        */

        /* calc path for the next hop */
        path_cost += zb_nwk_calc_path_cost(disc_ent->sender_addr);
        TRACE_MSG(TRACE_NWK1, "sum path_cost to next hop %hd", (FMT__H, path_cost));

        /*
          The destination address
          in the command frame NWK header shall be set to the next hop address and the
          frame shall be unicast to the next hop device using the MCPS-DATA.request
          primitive.The DstAddr parameter of the MCPS-DATA.request primitive shall be
          set to the next-hop address from the route discovery table.
        */
        zb_nwk_mesh_send_rrep(buf, nwk_cmd_rrep->rreq_id, nwk_cmd_rrep->originator, nwk_cmd_rrep->responder, path_cost,
                              disc_ent->sender_addr, nwk_cmd_rrep->opt);

        /* zb_nwk_mesh_send_rrep is now responsible for buf */
        buf = 0;

        /*
          If the value of the nwkSymLink attribute of the NIB has a value of TRUE, the
          NWK layer shall, upon relaying the route reply command frame, also create a
          reverse routing table entry if such an entry does not yet exist. The value of the
          destination address field of the routing table entry shall correspond to the value of
          the originator address field of the route reply command frame. The status field
          shall have a value of ACTIVE. The next-hop address field shall have a value
          corresponding to the next hop address in the route reply command being relayed,
          as determined in the previous paragraph. If the reverse routing table entry already
          exists the next-hop address field shall be updated, if necessary.
        */
#ifdef ZB_PRO_STACK
        add_rev_route(nwk_cmd_rrep->originator, disc_ent->sender_addr, ZB_NWK_RREQ_TYPE_NOT_MTORR);
#endif

    } /* else - forward rrep */

done:
    if ( buf != 0U )
    {

        TRACE_MSG(TRACE_NWK1, "free buf %p", (FMT__P, buf));
        zb_buf_free(buf);
    }
    TRACE_MSG(TRACE_NWK1, "<< rrep_handler", (FMT__0));
}


static void zb_nwk_mesh_send_pending_data(zb_uint16_t dest_addr)
{
    zb_uint_t i;

    TRACE_MSG(TRACE_NWK1, "zb_nwk_mesh_send_pending_data dest_addr 0x%x", (FMT__H, dest_addr));

    for (i = 0; i < ZB_NWK_PENDING_TABLE_SIZE; i++)
    {
        if ( ZB_U2B(ZB_NIB().pending_table[i].used)
                && ZB_NIB().pending_table[i].dest_addr == dest_addr )
        {
            zb_apsde_data_ind_params_t *pkt_params;

            TRACE_MSG(TRACE_NWK1, "pend ent %d dest_addr %d exp %d param %i",
                      (FMT__D_D_D_H,
                       i, ZB_NIB().pending_table[i].dest_addr, ZB_NIB().pending_table[i].expiry,
                       ZB_NIB().pending_table[i].param));

            /*cstat !MISRAC2012-Rule-20.7 See ZB_BUF_GET_PARAM() for more information. */
            pkt_params = ZB_BUF_GET_PARAM(ZB_NIB().pending_table[i].param,
                                          zb_apsde_data_ind_params_t);
            pkt_params->handle = ZB_NIB().pending_table[i].handle;
            ZB_SCHEDULE_CALLBACK(zb_nwk_forward, ZB_NIB().pending_table[i].param);
            NWK_ARRAY_PUT_ENT(ZB_NIB().pending_table, &ZB_NIB().pending_table[i], ZB_NIB().pending_table_cnt);
        }
    }
}


static void nwk_route_disc_failed(zb_uint8_t param, zb_uint16_t status_ind_addr)
{
    zb_nlme_status_indication_t *status =  ZB_BUF_GET_PARAM(param, zb_nlme_status_indication_t);
    zb_neighbor_tbl_ent_t *nbt_entry = NULL;

    TRACE_MSG(TRACE_NWK1, ">> nwk_route_disc_failed param %hd status_ind_addr 0x%x", (FMT__H_D, param, status_ind_addr));

    status->status = ZB_NWK_COMMAND_STATUS_NO_ROUTE_AVAILABLE;
    status->network_addr = status_ind_addr;

    /* DD: don't remove a device from NBT if it is our child.
       Rationale: every time another device performs a route discovery to our child,
       we will create a route entry, a route discovery entry, which will expire and we will be here.
    */
    if (zb_nwk_neighbor_get_by_short(status_ind_addr, &nbt_entry) == RET_OK
            && (nbt_entry->device_type != ZB_NWK_DEVICE_TYPE_ED
                && nbt_entry->relationship != ZB_NWK_RELATIONSHIP_CHILD))
    {
        /* If we have that device in neighboars and route discovery of it failed, clear nbt if it exist (it can, whih send_via_routing flag set).
           Is here right and/or the only place for such cleanup?
        */
        (void)zb_nwk_neighbor_delete(nbt_entry->u.base.addr_ref);
    }

    /* notify */
    ZB_SCHEDULE_CALLBACK(zb_nlme_status_indication, param);

    TRACE_MSG(TRACE_NWK1, "<< nwk_route_disc_failed", (FMT__0));
}

/* This function called periodically to find expired discovery table entries */
void zb_nwk_mesh_expiry_route_disc(zb_uint8_t param)
{
    ZVUNUSED(param);
    TRACE_MSG(TRACE_NWK3, ">> exp_r_disc", (FMT__0));

    if (ZB_IS_DEVICE_ZC_OR_ZR() && ZB_U2B(ZB_NIB().route_disc_table_cnt) )
    {
        zb_ushort_t i;

        TRACE_MSG(TRACE_NWK1, "disc tbl ent cnt %hd", (FMT__H, ZB_NIB().route_disc_table_cnt));
        for (i = 0; i < ZB_NWK_ROUTE_DISCOVERY_TABLE_SIZE; i++)
        {
            if ( ZB_U2B(ZB_NIB().route_disc_table[i].used) )
            {
                TRACE_MSG(TRACE_NWK1, "ent %hd exp_time %d", (FMT__H_D, i, ZB_NIB().route_disc_table[i].expiration_time));
                if ( ZB_U2B(ZB_NIB().route_disc_table[i].expiration_time) )
                {
                    ZB_NIB().route_disc_table[i].expiration_time--;
                }
                else
                {
                    zb_nwk_routing_t *route_ent;

                    /* free corresponding route record if it's state is not active */
                    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, route_ent,
                                       (route_ent->dest_addr == ZB_NIB().route_disc_table[i].dest_addr)
                                       && (route_ent->status != ZB_NWK_ROUTE_STATE_ACTIVE) );

                    /* free expired route discovery entry */
                    TRACE_MSG(TRACE_NWK1, "free disc ent %d %p dst_addr %d", (FMT__D_P_D, (int)i, &ZB_NIB().route_disc_table[i], ZB_NIB().route_disc_table[i].dest_addr));
                    NWK_ARRAY_PUT_ENT(ZB_NIB().route_disc_table, &ZB_NIB().route_disc_table[i], ZB_NIB().route_disc_table_cnt);

                    if (route_ent != NULL)
                    {
                        /* Don't send nwk status for MTORR */
                        if (!ZB_NWK_IS_ADDRESS_BROADCAST(route_ent->dest_addr))
                        {
                            /* report nwk status to the higher layers */
                            if (zb_buf_get_out_delayed_ext(nwk_route_disc_failed, route_ent->dest_addr, 0) != RET_OK)
                            {
                                TRACE_MSG(TRACE_ERROR, "Oops - out of memory, can't indicate route disc fail", (FMT__0));
                            }
                        }

                        TRACE_MSG(TRACE_NWK1, "free routing entrie, addr %d", (FMT__D, route_ent->dest_addr));
                        NWK_ARRAY_PUT_ENT(ZB_NIB().routing_table, route_ent, ZB_NIB().routing_table_cnt);
                        break;
                    }
                }
            }
        }
    }

    if (ZB_IS_DEVICE_ZC_OR_ZR())
    {
        /* Schedule to call later */
        ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_route_disc, 0, ZB_NWK_EXPIRY_ROUTE_DISCOVERY);
    }

    TRACE_MSG(TRACE_NWK3, "<< exp_r_disc", (FMT__0));
}

/* This function called periodically to find expired pending elements */
void zb_nwk_mesh_expiry_pending(zb_uint8_t param)
{
    ZVUNUSED(param);
    TRACE_MSG(TRACE_NWK3, ">> exp_pend", (FMT__0));

    if (ZB_IS_DEVICE_ZED())
    {
        return;
    }

    if (ZB_U2B(ZB_NIB().pending_table_cnt))
    {
        zb_ushort_t i;

        for (i = 0; i < ZB_NWK_PENDING_TABLE_SIZE; i++)
        {
            if ( ZB_U2B(ZB_NIB().pending_table[i].used) )
            {
                TRACE_MSG(TRACE_NWK1, "pend ent %d dst_addr %d exp %d param %i", (FMT__D_D_D_H,
                          i, ZB_NIB().pending_table[i].dest_addr, ZB_NIB().pending_table[i].expiry,
                          ZB_NIB().pending_table[i].param));

                if ( !ZB_U2B(ZB_NIB().pending_table[i].expiry) )
                {
                    if (ZB_NIB().pending_table[i].handle >= ZB_NWK_MINIMAL_INTERNAL_HANDLE)
                    {
                        TRACE_MSG(TRACE_ERROR, "Free internal pending entry, param %hd",
                                  (FMT__H, ZB_NIB().pending_table[i].param));

                        zb_buf_free(ZB_NIB().pending_table[i].param);
                    }
                    else
                    {

                        TRACE_MSG(TRACE_NWK1, "Call zb_nlde_data_confirm(), param %hd",
                                  (FMT__H, ZB_NIB().pending_table[i].param));
                        /* ZB_NWK_STATUS_ROUTE_ERROR to detect presence of NWK header and
                         * absence of MAC header in zb_nlde_data_confirm() */
                        nwk_call_nlde_data_confirm(ZB_NIB().pending_table[i].param, ZB_NWK_STATUS_ROUTE_ERROR, ZB_TRUE);
                    }
                    NWK_ARRAY_PUT_ENT(ZB_NIB().pending_table, &ZB_NIB().pending_table[i], ZB_NIB().pending_table_cnt);
                }
                else
                {
                    ZB_NIB().pending_table[i].expiry--;
                }
            }
        }
    }

    /* NK: check expiry for routing_table also */
    if ( ZB_U2B(ZB_NIB().routing_table_cnt) )
    {
        zb_ushort_t i;

        for (i = 0; i < ZB_NWK_ROUTING_TABLE_SIZE; i++)
        {
            if ( ZB_U2B(ZB_NIB().routing_table[i].used) )
            {
                TRACE_MSG(TRACE_NWK1, "routing_table ent %d dst_addr %d exp %d status %i",
                          (FMT__D_D_D_H, i, ZB_NIB().routing_table[i].dest_addr,
                           ZB_NIB().routing_table[i].expiry, ZB_NIB().routing_table[i].status));

                if (!ZB_U2B(ZB_NIB().routing_table[i].expiry))
                {
                    NWK_ARRAY_PUT_ENT(ZB_NIB().routing_table, &ZB_NIB().routing_table[i], ZB_NIB().routing_table_cnt);
                }
                else
                {
                    if (ZB_NIB().routing_table[i].status == ZB_NWK_ROUTE_STATE_ACTIVE)
                    {
                        --(ZB_NIB().routing_table[i].expiry);
                    }
                }
            }
        }
    }

#ifndef ZB_LITE_NO_SOURCE_ROUTING
    /* Check expiry for the source route table also */
    zb_nwk_source_route_table_expiry();
#endif /* ZB_LITE_NO_SOURCE_ROUTING */

    /* Schedule to call later */
    if (ZB_U2B(ZB_PIBCACHE_RX_ON_WHEN_IDLE()))
    {
        ZB_SCHEDULE_ALARM(zb_nwk_mesh_expiry_pending, 0, ZB_NWK_EXPIRY_PENDING);
    }

    TRACE_MSG(TRACE_NWK3, "<< exp_pend", (FMT__0));
}

#if defined ZB_PRO_STACK
zb_nwk_routing_t *zb_nwk_mesh_find_route(zb_uint16_t dest_addr)
{
    zb_nwk_routing_t *route;
    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, route, (route->dest_addr == dest_addr));

    if (route != NULL)
    {
        TRACE_MSG(TRACE_NWK3, "route to 0x%x dst 0x%x next_hop_ref %hd used %hd status %hd",
                  (FMT__D_D_H_H_H, dest_addr, route->dest_addr, route->next_hop_addr_ref, route->used, route->status));
    }

    return route;
}
#else
zb_nwk_routing_t *zb_nwk_mesh_find_route(zb_uint16_t dest_addr)
{
    zb_nwk_routing_t *route;
    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, route, (route->dest_addr == dest_addr));

    return route;
}
#endif

zb_nwk_route_discovery_t *zb_nwk_mesh_find_route_discovery_entry(zb_uint16_t dest_addr)
{
    zb_nwk_route_discovery_t *disc_ent;
    NWK_ARRAY_FIND_ENT(ZB_NIB().route_disc_table, ZB_NWK_ROUTE_DISCOVERY_TABLE_SIZE, disc_ent, disc_ent->dest_addr == dest_addr);
    return disc_ent;
}

zb_ret_t zb_nwk_mesh_add_buf_to_pending(zb_uint8_t param, zb_uint8_t handle)
{
    zb_ret_t ret = RET_OK;
    zb_nwk_hdr_t *nwhdr = (zb_nwk_hdr_t *)zb_buf_begin(param);
    zb_nwk_pend_t *pend;

    /*cstat -MISRAC2012-Rule-13.5 */
    /* After some investigation, the following violation of Rule 13.5 seems to be
     * a false positive. There are no side effects to 'zb_buf_memory_low()' and
     * 'zb_buf_memory_close_to_low()'. This violation seems to be caused by the
     * fact that 'zb_buf_memory_low()' and 'zb_buf_memory_close_to_low()' are
     * external functions, which cannot be analyzed by C-STAT. */
    if (handle >= ZB_NWK_MINIMAL_INTERNAL_HANDLE &&
#ifdef ZB_REDUCE_NWK_LOAD_ON_LOW_MEMORY
            zb_buf_memory_close_to_low()
#else
            zb_buf_memory_low()
#endif
       )
    {
        /* do not try to discover route if we have no memory */
        ret = RET_NO_MEMORY;
    }
    else
    {
        NWK_ARRAY_GET_ENT(ZB_NIB().pending_table, pend, ZB_NIB().pending_table_cnt);
        if ( pend != NULL )
        {
            TRACE_MSG(TRACE_NWK1, "buf %hd added to pendlist", (FMT__H, param));
            pend->param     = param;
            pend->handle    = handle;
            pend->dest_addr = nwhdr->dst_addr;
            pend->expiry    = ZB_NWK_PENDING_ENTRY_EXPIRY;
            pend->waiting_buf = 1;
        }
        else
        {
            ret = RET_NO_MEMORY;
        }
    }

    return ret;
}

void zb_nwk_mesh_routing_deinit()
{
    TRACE_MSG(TRACE_NWK1, ">> r_deinit", (FMT__0));

    ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_pending, ZB_ALARM_ANY_PARAM);
    ZB_SCHEDULE_ALARM_CANCEL(zb_nwk_mesh_expiry_route_disc, ZB_ALARM_ANY_PARAM);

    TRACE_MSG(TRACE_NWK1, "<< r_deinit", (FMT__0));
}

/* Calculate path cost */
zb_uint8_t zb_nwk_calc_path_cost(zb_uint16_t src_addr)
{
    if ( !ZB_U2B(ZB_NIB().nwk_report_constant_cost) )
    {
        zb_neighbor_tbl_ent_t *nbt;
        if ( zb_nwk_neighbor_get_by_short(src_addr, &nbt) == RET_OK )
        {
            zb_uint8_t incoming_cost = ZB_NWK_NEIGHBOUR_GET_PATH_COST(nbt);
#ifndef ZB_PRO_STACK
            TRACE_MSG(TRACE_NWK3, "cost for 0x%x lqi = 0x%x cost %d",
                      (FMT__D_H_H, src_addr, nbt->lqi, incoming_cost));
            return incoming_cost;
#else
            /*
            3.6.3.5.2 Upon Receipt of a Route Request Command Frame

            The maximum of the
            incoming and outgoing costs for the neighbor is used for the purposes of the path
            cost calculation, instead of the incoming cost.
             */
            if (!ZB_U2B(nbt->u.base.outgoing_cost) && nbt->device_type != ZB_NWK_DEVICE_TYPE_ED)
            {
                TRACE_MSG(TRACE_NWK1, "nbt for 0x%x is expired - will drop RREQ", (FMT__D, src_addr));
                return ZB_NWK_STATIC_PATH_COST + 1U;
            }
            /* nbt->outgoing_cost will be always 0 for ZED */
            else if (nbt->u.base.outgoing_cost > incoming_cost)
            {
                TRACE_MSG(TRACE_NWK3, "returning outgoing cost for 0x%x lqi %d inc cost %hd out cost %hd",
                          (FMT__D_D_H_H, src_addr, nbt->lqi, incoming_cost, nbt->u.base.outgoing_cost));
                return nbt->u.base.outgoing_cost;
            }
            else
            {
                TRACE_MSG(TRACE_NWK3, "returning incoming cost for 0x%x lqi %d inc cost %hd out cost %hd",
                          (FMT__D_D_H_H, src_addr, nbt->lqi, incoming_cost, nbt->u.base.outgoing_cost));
                return incoming_cost;
            }
#endif
        }
        else if ( (src_addr) == ZB_PIBCACHE_NETWORK_ADDRESS() )
        {
            TRACE_MSG(TRACE_NWK3, "RREQ from/to us - return cost 0", (FMT__0));
            return 0;
        }
        else
        {
            TRACE_MSG(TRACE_NWK1, "No nbt for 0x%x", (FMT__D, src_addr));
            return ZB_NWK_STATIC_PATH_COST + 1U;
        }
    }

    TRACE_MSG(TRACE_NWK3, "return static cost %hd", (FMT__H, ZB_NWK_STATIC_PATH_COST));
    return ZB_NWK_STATIC_PATH_COST;
}


void zb_nwk_reset_route_expire(zb_uint16_t addr)
{
    zb_nwk_routing_t *route_ent;

    TRACE_MSG(TRACE_NWK2, "check for routing_table entry addr 0x%x", (FMT__D, addr));
    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, route_ent,
                       (route_ent->dest_addr == addr)
                       && (route_ent->status == ZB_NWK_ROUTE_STATE_ACTIVE));

    if (route_ent != NULL)
    {
        TRACE_MSG(TRACE_NWK2, "route entry for 0x%x found, reset expiry", (FMT__D, addr));
        route_ent->expiry = ZB_NWK_ROUTING_TABLE_EXPIRY;
    }
}


void zb_nwk_route_expire(zb_uint16_t addr)
{
    zb_nwk_routing_t *route_ent;

    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, route_ent,
                       (route_ent->dest_addr == addr)
                       && (route_ent->status == ZB_NWK_ROUTE_STATE_ACTIVE));

    if (route_ent != NULL && ZB_U2B(route_ent->expiry))
    {
        if (route_ent->expiry < ZB_NWK_ROUTING_FAILURE_EXPIRY_STEP)
        {
            route_ent->expiry = 0;
        }
        else
        {
            route_ent->expiry -= ZB_NWK_ROUTING_FAILURE_EXPIRY_STEP;
        }

        TRACE_MSG(TRACE_NWK2, "tx failure. Expire route entry for 0x%x, expiry %hd", (FMT__D_D, addr, (int)route_ent->expiry));
    }
}


void zb_nwk_mesh_delete_route(zb_uint16_t addr)
{
    zb_nwk_routing_t *route_ent;

    TRACE_MSG(TRACE_NWK1, ">> zb_nwk_mesh_delete_route addr 0x%x", (FMT__D, addr));

    NWK_ARRAY_FIND_ENT(ZB_NIB().routing_table, ZB_NWK_ROUTING_TABLE_SIZE, route_ent, (route_ent->dest_addr == addr));

    NWK_ARRAY_PUT_ENT(ZB_NIB().routing_table, route_ent, ZB_NIB().routing_table_cnt);

    TRACE_MSG(TRACE_NWK1, "<< zb_nwk_mesh_delete_route", (FMT__0));
}

/*! @} */

#endif /* ZB_NWK_MESH_ROUTING && ZB_ROUTER_ROLE */
